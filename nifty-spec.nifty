// [TOP]
// [HELLO WORLD]
// [COMMENTS]
// [VARIABLES]
// [TYPES]
// [PACKAGES]
// [FUNCTIONS]
// [CONTROL FLOW]
// [DEFER]
// [RANGES]
// [ARRAYS]
// [SLICES]
// [ENUMS]
// [STRUCTS]
// [OOP]
// [GENERICS]
// [POINTERS]
// [FUNCTION POINTERS]
// [MACROS]
// [MISC]
// [WITH]
// [BUILDING]

// Nifty is a new systems programming language in development.
// This file is an overview of the language and (basically) everything in here is
// subject to change. I am open to suggestion and if anything is unclear let me
// know. This file is much easier to read in vscode with the nifty extension.
// The extension is in the highlighting/vscode folder and you can copy and paste
// it into you vscode extensions folder to install it. You will have to restart
// vscode for it to go into effect.

/-

Naming conventions:

The following naming conventions are my personal preference and are what nifty uses.
These are not enforced by the compiler.

functions:          camelCase
types:              PascalCase
enum values:        PascalCase
variables:          camelCase
macros:             camelCase
constants:          SCREAMING_SNAKE_CASE
package names:      snake_case
keywords:           snake_case
built-in functions: snake_case
built-in types:     snake_case

The following naming conventions ARE enforced by the compiler.

Exports may not start with an underscore.
Privates must start with an underscore.

-/

// [HELLO WORLD]

package main

use "nsl.fmt"

fn main() {
    fmt::println(“Hello world!”)
}

// Semicolons are optional.

// [COMMENTS]

// Single line comments use '//'.
// This is a comment.

/-
    Multiline comments use '/-' and '-/'
    Comments can be nested so the following is valid
-/

/-
    /-
        // bla
    -/
-/

/- Multiline comments can be on just one line too -/

/*
    C-style comments can be used as well and mixed with nifty comments.
*/

/-
    Like so
    /*
        and so
    -/
*/

// Why not just use /* */? I'm lazy, but you do you.

// [VARIABLES]

// Variables are declared with the 'let' keyword.
let x = 12

// The variable declaration operator can be used as well.
x := 12 // int
y := 12.f // f32
y := 12.0 // f32 (or should it be f64?)

// The types are inferred but can be specified.
let x: int = 12
x: int = 12

// If no value is specified the type must be specified
let x // Invalid
let x: int // Valid

// Immutable variables (runtime constants) are declared with the 'val' keyword.
val x = 12

// The constant declaration operator can be used as well.
x ::= 12

// The type is inferred for constants as well but it can also be specified.
val x: int = 12
x :: int = 12
val y: int

// Variables are auto initialized in Nifty.
let x: int
y := x // Valid, both will be 0

// Variables can be explicitly uninitialized
let x: int = undefined
x := undefined // Invalid, no type given
x: int = undefined // Valid

// It is important to know that undefined is only used for declaring variables. 
// You can't check to see if a variable is undefined.
if (x == undefined) // Invalid
// Because of this undefined is NOT null
undefined == null // Invalid

// A variabled can't be later set to undefined.
x := 12
x = undefined // Invalid

lateinit let buf: u32 = undefined // Or lateinint buf: u32 = undefined
genBuffers(1, &buf) // buf gets initialized here (Should this generate an error if lateinit is not used?)
y := buf // Valid

// Nifty does not support variable shadowing.

fn someFunc(x: int) {
    x := 12 // Invalid
}

fn someFunc() {
    someVar := 12
    {
        someVar := 42 // Invalid
    }
}

// Variables can also be unused.
// Lets say you have a function getFromTable that returns true if the key is in the
// table, false otherwise, and takes a pointer to a Value that's where the value gets
// set if it is in the table. But you don't care about the value in the table  you
// just want to know if it is there and there is no other way provided by the library.
// This is a contrived example because nifty supports multiple returns.

let val: Value = undefined
inTable := getFromTable(someTable, someKey, &val)
// This will give an error that 'val' isn't being used.

let unused: Value = undefined
inTable := getFromTable(someTable, someKey, &unused)
// 'unused' is a special variable name that lets the compiler know the variable is
// unused. In the case 'getFromTable' will be able to set the variable from inside
// the function and then the unused variable will be immediatly freed and can be
// used again.

let unused: Value = undefined
inTable := getFromTable(someTable, someKey, &unused)

let unused: Value = undefined // Because 'unused' is a special variable name it can be redefined.
inTable2 := getFromTable(someOtherTable, someOtherKey, &unused)

// If it will be used with the same type it doesn't have to be redefined.
let unused: Value = undefined
inTable := getFromTable(someTable, someKey, &unused)
inTable2 := getFromTable(someOtherTable, someOtherKey, &unused) // Also valid

// [CONSTANTS]

// Constants use the 'const' keyword and their value must be determined at compile time.
const x = 12
const y = someFunc() // Invalid
const z = $MACRO_CONST // Valid

// The constant declaration operator can be used as well.

x ::= 12

// The compiler will differenciate between a runtime constant and a compile time
// constant so the same operator can be used.

// [TYPES]

// Basic Types:
char // same as s32
int // same as s32
uint // same as u32
float // same as f32
double // same as f64

bool b8 b16 b32 b64

u8 u16 u32 u64 u128
s8 s16 s32 s64 s128

f16 f32 f64

string

// Strings will be fully supported via the standard library, the string type is very basic.
// Strings (nsl.string) will be included by default since they are so common. (Maybe?)

// Custom types can be created as follows:

type Custom as int

// Casting uses the 'cast' operator.

x: s8 = 100
y := cast(x, s32) // cast(var, type)

// Types in nifty are not implicitly converted.

x := 12
y := 42
z: f64 = x / y // Invalid
z: f64 = cast(x, f64) / cast(y, f64) // Valid
z: f64 = cast(x / y, f64) // Valid, but probably not what you want.

x := 12
if (x) { /- ... -/ } // Invalid
if (x != 0) { /- ... -/ } // Valid

b := true
if (b) { /- ... -/ } // Valid
if (b == true) { /- ... -/ } // Valid, but like why?

p: ^int = null
if (p) { /- ... -/ } // Invalid
if (p != null) { /- ... -/ } // Valid

// [PACKAGES]

// All nifty programs are made of packages.

package main

use "nsl.fmt"
use "nsl.math"

fn main() {
    // Do something
}

// By default the name of the package is the last element of the package 
// path, which is also the name of the package in the file. This, however,
// can be changed with the 'as' keyword

use "nsl.fmt"
use "nsl.math" as M
use "nsl.math.random"

fn main() {
    fmt::println(M::PI) // math::PI is invalid
    fmt::println(random::number())
}

// Note the 'random' is a package inside the 'math' package and must be used
// separately from 'math'.

// All items inside a package can be added to the current scope with the 'using' keyword.

use "nsl.fmt"
using fmt // All items exported from the package fmt are now in this file's scope.

fn main() {
    println("Yo whaddup?")
}

// --- --- --- --- ---

use "nsl.fmt"

fn sayHi() {
    using fmt // All items from the package fmt are now in this function's scope.
    println("Hello")
}

fn main() {
    fmt::println("Yo whaddup?")   
}

// 'using' can also be used to import the package and bring it in to the file scope.
using "nsl.fmt"

fn main() {
    println("Hello world!")
}

// If two packages are brought into the same scope and they have any exported symbols
// with the same name then the package name must be provided to avoid ambiguity.

use "nsl.fmt"
use "foo"

using fmt
using foo // Lets say that package 'foo' also has a println function.

fn main() {
    println("Ya yeet") // Invalid
    foo::println("Yote") // Valid
}

// All items not marked local and not starting with an underscore are exported
// from the package.

package example

let _privateVar: int // Private to the package.
let exportedVar: f64
local let localVar: string // Private to the file, doesn't need to start with an underscore.

const exportedConst = 100
const _privateConst = 42
local const localConst = 12

fn _somePrivateFunction() {
    // Do something
}

fn exportedFunction() {
    // Do something
}

local fn localFunction() {
    // Do something
}

type _PrivateStruct struct {
    // Stuff
}

type ExportedStruct struct {
    // Stuff
}

local type LocalStruct struct {
    // Stuff
}

// etc...

// [FUNCTIONS]

// Functions are declared with the 'fn' keyword.

fn someFunc() {
    // Do something
}

// Functions can have arguments.

fn sayHi(name: string) {
    fmt::println("Hi", name)
}

// ...and return types

fn add(a: int, b: int): int {
    return a + b
}
// ...and multiple return types
fn openFile(name: string): File, error {
    // do stuff
}

// If two or more consecutive arguments have the same type the type can be omitted for all but the
// last argument of that type.
fn add(a, b: int): int {
    return a + b
}

// Functions can have default arguments

fn add(a := 10, b := 10): int {
    return a + b
}

// Here type inference was used for the argument types but they can be specified as well.

fn add(a: int = 10, b: int = 10): int {
    return a + b
}

// Non-default arguments can't come after default arguments.

// Invalid
fn add(a := 10, b := 10, c: int): int {
    return a + b + c
}

// If a function returns something the type must be specified in the function definition.
// A function can be explicitly marked as not having a return. This is purely for the programmers
// convenience, there is no difference for the compiler. 

fn yeet(): void {
    fmt::println("Yeet")
}

// All function arguments are immutable.

fn someFunc(x: int) {
    x = 12 // Invalid
}

// If you need to change the argument for some reason you must make a copy.
fn someFunc(x: int) {
    newX := x
    newX = 12 // Valid
}

// Pointers can also be used to change the value.

fn someFunc(x: ^int) {
    newX := x
    newX^ = 12
}

let x: ^int
x^ = 2
someFunc(^x) // See section on pointers for an explination.
// x is now 12

// Functions can be variadic, meaning they can take a variable number of arguments.
// The variadic argument can be treated like a static array.
fn sum(nums: ..int): int {
    res := 0
    for (n in nums) {
        res += n
    }
    
    return res
}

sum()
sum(1, 2, 3)
sum(4, 5, 6, 7, 8)

// If a variadic function requires a minimum number of arguments to work, that can be specified with $min_arity(int).

$min_arity(2)
fn sum(nums: ..int): int {
    res := 0
    for (n in nums) {
        res += n
    }
    
    return res
}

sum() // Invalid
sum(2, 2) // Valid

// $max_arity(int) can also be used.
// Did you know that a function with 9 arguments is called Novenary? Well now you do!

// Arguments can't come after a variadic argument.
fn counts(cnts: ..int, type: string) // Invalid

// Nifty has function overloading, but it works differently compared to languges like c/c++.
// Instead of two functions having the same name but different arguments the functions have
// different names and are explicetly overloaded. For instance if you had a pow function for
// int, float, and double it might look like this:

fn powi(x: int, y: int): int { /- ... -/ }
fn powf(x: float, y: float): float { /- ... -/ }
fn powd(x: double, y: double): double { /- ... -/ }

fn pow overloads{powi, powf, powd}

// This is done to be more explicit and searchable as well as making the compiler simpler to develop.

// The original functions can still be called or the overloaded function can be called.
a := 2.f
b := 8.f
x := 2
y := 8

z := powi(x, y)
w := pow(x, y) // Calls powi()
v := pow(a, b) // Calls powf()
u := powf(a, b)

// The following will not compile:

fn pow(x: int, y: int): int { /- ... -/ }
fn pow(x: float, y: float): float { /- ... -/ }
fn pow(x: double, y: double): double { /- ... -/ }

// Sometimes you want to guarantee the return variable is handled.
// $keep can be used to force the return variable to be used.
// Very similar to [[nodiscard]] in c++.

$keep // Do I like this syntax? Why should it be different from inline/local?
fn returnsError(): error {
    // do stuff
}

// This will force the caller to handle the returned error.

// Do something
returnsError() // Invalid
// Do more things

// Do something
err := returnsError() // Invalid, err isn't being used.
// Do more things

// Do something
unused := returnsError() // Invalid, can't use unused.
// Do more things

// Do something
err := returnsError() // Valid
if (err != null) {
    // Handle error.
}
// Do more things

// Functions can be inlined with the 'inline' keyword.
inline fn smallFastFn() { /- ... -/ }
// Or explicetly not inlined with
noinline fn bigSlowFn() { /- ... -/ }

// [CONTROL FLOW]

// For loops work much like they do in c/c++

for (i := 0; i < 10; ++i) {
    // Do something
}

// But aslo have ranges

for (0 .. 10) { /- ... -/ } // [a, b]
for (0 ..< 10) { /- ... -/ } // [a, b)
for (0 .. 10 step 2) { /- ... -/ }
for (i in 0 .. 10 step 2) { /- ... -/ } // i is implicitly immutable here
for (val str in strings) { /- ... -/ }

// While loops work like they do in c/c++.

while (thing) {
    // Do something
}

do {
    // Something
} while (thing)

// Until loops. The opposite of while loops.

until (thing) {
    // Do something
}

do {
    // Something
} until (thing)

// When statements are much like switch statements in c/c++.

x := 2
when (x) {
    1: fmt::println("one")
    2: fmt::println("two")
    3: fmt::println("three")
    else: fmt::println("???")
}

// Multiple cases can be handled at once.

when (x) {
    1, 3, 5, 7, 9: fmt::println("odd")
    2, 4, 6, 8, 10: fmt::println("even")
    else: fmt::println("???")
}

// Ranges can also be used.

when (x) {
    in 0 ..< 10: fmt::println("0 ..< 10")
    in 10 .. 100: fmt::println("10 .. 100")
    else: fmt::println("big")
}

// By default cases do not fall through. To fall through use '->'.

x := 2
when (x) {
    1 -> fmt::println("one")
    2 -> fmt::println("two")
    3: fmt::println("three")
    else: fmt::println("???")
}

// The above when statement will trigger 2 and 3.

// When is not just limited to numbers.

str := "one"
when (str) {
    "one": fmt::println("1")
    "two", "three": fmt::println("2 or 3")
    else: fmt::println("???")
}

strs0 := []string{"one", "two", "three"}
strs1 := []string{"four", "five", "six"}
str := "two"

when (str) {
    in strs0: fmt::println("1, 2, or 3")
    in strs1: fmt::println("4, 5, or 6")
    else: fmt::println("???")
}

// In general 'else' is required with when statements. 
// The exception is with enums where the values the variable can be are 
// limited and it is possible to capture all options. 
// See the enums section for an example of this.

// If statements. Work how they do in c/c++ with the addition of elif.

if (thing) {
    // Do something 1
} else if (thing2) {
    // Do something 2
} elif (thing3) {
    // Do something 3
} else {
    // Do something 4
}

// Logic operators work the same as in c/c++.
// && for and
// || for or
// ! for not

// Ternary operator. Ternary operators can't be nested.

trueCondition ::= 12
falseCondition ::= 42
condition ::= true
x := condition ? trueCondition : falseCondition

// [RANGES]

1 .. 5 // [1, 5] 1, 2, 3, 4, 5
1 ..< 5 // [1, 5) 1, 2, 3, 4

rangeVar := 0 .. 10 // type range
x := 12

if (x in range) {
    // Do something
}

// Maybe? Not sure if I want a range type or not.

// [DEFER]

// 'defer' defers the execution of code until the end of the current scope.

fn someFunc() {
    // stuff
    someFile.open("myFile.txt")
    defer someFile.close()
    // more stuff
}

// Blocks of code can be deffered as well.

fn anotherFunc() {
    defer {
        call1()
        if (condition) {
            call2()
        }
    }
    // stuff
}

// Defer statements can be stacked as well and are executed in a First In Last Out (FILO) fashion.

package main
using "nsl.fmt"

fn main() {
    for (i in 0 ..< 5) {
        defer println(i)
    }
    println("Hello world")
}

/- Will print the following:
Hello world
4
3
2
1
0
-/

// [ARRAYS]

// Nifty has both static and dynamic arrays.
// Static arrays work as follows.

arr: [5]int // Array of 5 integers, auto initialized to [0, 0, 0, 0, 0]
arr := [5]int{1, 2, 3, 4, 5} // Array of 5 integers initialized to [1, 2, 3, 4, 5]
arr := []int{1, 2, 3, 4, 5} // Array of 5 integers where the length is inferred.
arr := [5]int{5} // Array of 5 integers initialized to [5, 5, 5, 5, 5]
arr: []int // Valid, dynamic, not static.
arr: [5]int = undefined // Array of 5 integers not initialized to anything.
// Should static arrays be able to infer type?
arr := ["one", "two", "etc"]
// is the same as
arr := []string{"one", "two", "etc"}

// Arrays are 0 indexed.
arr := []int{1, 2, 3, 4, 5}
x := arr[0] // x is 1
arr[2] = 12 // [1, 2, 12, 4, 5]
// Arrays are bounds checked at compile time and runtime.
x := arr[5] // Compile time error.
arr[12] = 42 // Compile time error.

y := 5
x := arr[y] // Runtime error.

// Runtime bounds checking can be disabled at a block level with $noBoundsCheck
// This can be important in situations where performance is critical. Could lead to undefined behavior.
$noBoundsCheck {
    x = arr[y] // Y could still be out of bounds.
}

// To get the length of an array use the included len() function.
assert(len(arr) == 5) // true
// Static arrays can't have their length changed.

// Dynamic arrays are made with the included make() function.

arr := make([]int) // Dynamic array with length 0 and capacity 0
arr := make([]int, 5) // // Dynamic array with length 5 and capacity 5 auto initialized to [0, 0, 0, 0, 0]
arr := make([]int, 0, 5) // // Dynamic array with length 0 and capacity 5 auto initialized to []

// To get the capacity of an array use the included cap() function.
assert(cap(arr) == 5) // true

// Dynamic arrays are bounds checked as well. Can be disabled with $noBoundsCheck as well.
arr[5] = 6 // Runtime error.

// To append to an array use the included append() function.
append(&arr, 4) // [5, 5, 5, 5, 5, 4]
// Multiple values can be appended at once.
append(&arr, 6, 7, 8, 9) // [5, 5, 5, 5, 5, 4, 6, 7, 8, 9]

// Dynamic arrays can be deleted with the 'delete' operator.
delete arr // [] or should it be null?

// Additional array functionality can be found in the nsl.array package.

/- Not sure if I should keep this. -/
// To fill an array with a specified value use the included fill() function.
arr := make([]int, 0, 5) // []
fill(arr, 5) // [5, 5, 5, 5, 5] Not sure if I should keep this.

// [SLICES]

// TODO

// [ENUMS]

type Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL,
    TK_FUNCTION,
    TK_VAR,
}

// The above example is just like enums in c/c++. So TK_STRING = 0, TK_NUMBER = 1 ...

type Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL = 5,
    TK_FUNCTION,
    TK_VAR,
}

// Unless otherwise specified enumerators take the value of the enumerator before them + 1.
// TK_STRING = 0, TK_NUMBER = 1, TK_BOOL = 5, TK_FUNCTION = 6 ...

// The values in an enum must be unique.

type Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL = 5,
    TK_FUNCTION,
    TK_VAR = 6, // Invalid
}

// More advanced patterns can be used as well for the increments.
type EvensForSomeReason enum {
    unused = $jot * 2
    First,  // 2
    Second, // 4
    Third,  // 8
}

type Permission enum {
    read = 1 << $jot, // 00000001
    write,            // 00000010
    delete,           // 00000100
}

type MemSize enum {
    unused = 1 << ($jot * 10)
    KB, // dec: 1024       bin: 00000000000000000000010000000000
    MB, // dec: 1048576    bin: 00000000000100000000000000000000
    GB, // dec: 1073741824 bin: 01000000000000000000000000000000
}

// 'jot' works much like 'iota' in go (the etymology nerds out there should love this).

// Enums can be types other than int. When this is the case all enumerators must be specified.

type Numbers enum: f64 {
    PI = 3.14159,
    E = 2.71828,
}

type Animals enum: string {
    Aardvark = "Aardvark",
    Cat = "Cat",
    Dog = "Dog",
}

// To get the name of a enumeration use the name_of operator.

num := Numbers.PI
name := name_of(num, Numbers)
fmt::println("num is ${name}") // Prints 'num is PI'

// If the value can't be found it will return an empty string.
num = 3.4
name = name_of(num, Numbers) // 'name' is an empty string.

// [STRUCTS]

type Point struct {
    x: int
    y: int
}

point := {x: 12, y: 42}
let p: Point
p.x = 12
p.y = 42

// [OOP]

// For methods the md keyword is used so that if the impl keyword is missed by a 
// programmer or a programmer jumps to the middle of the file it is obvious that
// these are methods and not ordinary functions. 

type Collection struct {
    list: []int
    _average: float // Private variable
}

impl Collection

// Constructor
md new() {
    list = make([]int)
}

md add(num: int) {
    append(list, num)
    _calculateAverage()
}

md average(): float {
    return _average
}

// Private function
md _calculateAverage() {
    total := 0
    for (val num in list) {
        total += num
	}

	average = cast(total, f32) / cast(len(list), f32)
}

endimpl

// Optionally the name of the struct can be specified with endimpl.
endimpl Collection
// This is just to improve readability in files with multiple struct implementations.
// This does not allow for impl nesting.

collection := new Collection() // Type is ^Collection
collection := new Collection{ /- ... -/ } // Type is ^Collection also. 
// This does not call the constructor and the fields in the struct are set to their defaults.
// The values can be specified.

collection := new Collection{list: make([]int)} // Private var can't be set.

collection->add(12) // Valid
// Is effectively the same as (but is not the same as)
add(collection, 12) // Invalid

// The calling object is implicetly passed in as 'this'.
// Because of this it is important to note that the object calling the function can be null.

collection = null
collection->add(12) // The function add will be called.

// In the function you can either check that
this != null
// or use '?' to require that the calling object not be null

md add?(num: int) {
    // Do something
}

// The compiler will error if collection can be null when the function is called.

collection->add(12) // Error! collection can be null

if (collection != null) {
    collection->add(12) // No error.
}

// If you don't allocate the object on the heap this is not an issue.

collection := Collection{list: make([]int)} // Type is Collection
collection.add(12) // No check needed even if '?' is used.

// You may have noticed that I used both '->' and '.' when calling the 
// functions. Nifty works like c++ in that objects that are pointers use 
// '->' and objects that are not pointers use '.'. This is to visually 
// distinguish the two.

// Optionally an interface can be used for improved readability and to force an implementation
// to implement the functions in the interface.

type Collection interface { // TODO(Skyler): Needs work.
    new()
    add()
    average()
    _calculateAverage()
}

// If an implementation is missing one or more of those functions it will cause a compiler error.

// [GENERICS]

fn add<T>(a, b: T): T {
    return a + b
}

type Point<T> struct {
    x: T
    y: T
}

// What if you wanted to store more than just int in the Collection struct above?
// Well then you would need to use generics.

type Collection<T> struct {
    list: []T
    _average: float // Private variable
}

impl Collection<T>

// Constructor
md new() {
    list = make([]T)
}

md add(num: T) {
    append(list, num)
    _calculateAverage()
}

md average(): float {
    return _average
}

// Private function
md _calculateAverage() {
    total := 0
    for (val num in list) {
        total += num
	}

	average = cast(total, f32) / cast(len(list), f32)
}

endimpl

collection := new Collection<f32>()
collection->add(12.f)

// You can also restrict methods to a certain type.

impl Collection<int>

md sum(): int {
    total := 0
    for (val num in list) {
        total += num
	}
}

endimpl

// The sum function is only available for Collection<int>.

collectionInt := new Collection<int>()
collectionF32 := new Collection<f32>()

// do stuff

sumInt := collectionInt->sum() // Valid
sumF32 := collectionF32->sum() // Comile error

// Generics are figured out at compile time so there is no runtime cost assosiated with them.

// [POINTERS]

// Pointers in nifty use the Pascal syntax.
// For types '^' is on the left and indicates it is a pointer type.
// For dereferencing '^' is on the right of the variable. 
// Like c/c++ '&' is the addressof operator.

let p: ^int // p is null
x := 12
p = &x // p now points to x
y := p^ // y is 12
p^ = 42 // x is 42

// If a function takes a pointer type then ^ is used on the left of the variable
// to visually indicate that.

fn someFunc(x: ^int) {
    // Do something
}

x := 12
y: ^int = &x

someFunc(^y) // Valid
someFunc(y) // Invalid
// This is not dereferencing y or doing anything other that passing y.
// This is just so the programmer can quickly see this function is taking
// a pointer and that y could potentially be modified by the function.
// TODO: Maybe this can be optiional and forced by a compiler flag?

// Nifty does not have pointer arithmetic.

let p: ^f64
// ...
p^ // Causes a panic if p is still null.

// If the compiler knows that a value is null when it is being dereferenced
// it will not compile.

let p: ^f64
p^ // Invalid

// The '?' token can be used to indicate that a pointer is not allowed to be
// null.

let p?: ^int // Invalid
let p?: ^int = new int // Valid
p = null // Invalid

// Nifty has null coalescing.

x := 12
p := &x

y := p^ ?? 12
// The above line is the same as
let y: int
if (p != null) {
    y = p^
} else {
    y = 12
}

p ??= &x
// The above line is the same as
if (p == null) {
    p = &x
}

// [FUNCTION POINTERS]

fn addFn(a, b: int): int {
    return a + b
}

fn otherFunc() {
    add := addFn // Type is ^fn(int, int): int
    add(2, 2)
}

type AddFn as fn(int, int): int

fn add(a, b: int): int { /- ... -/ }
type AddFn as type_from(add) // Also works

// [MACROS]

// Macros 

// TODO

// Built in macros

$file          // replaced with the filename
$path          // replaced with the full file path
$line          // replaced with the line the macro is on
$function      // replaced with the function name the macro is in
$os            // replaced with the OS that the compiler is running on currecntly
$time          // replaced with the current time
$date          // replaced with the current date

$niftyVersion      // replaced with the version of the nifty compiler
$niftyVersionMajor //
$niftyVersionMinor //
$opt               // replaced with the current optimization level

$counter           // replaced by an incremented value starting at 0, it is incremented everytime it is encountered and never reset
$jot               // replaced by an incremented value starting at 0, it is incremented everytime it is encountered and reset every block

$noBoundsCheck

// Function related.
$keep
$min_arity(int)
$max_arity(int)
$deprecated
$maybeUnused

$error(string) // Causes the compiler to error with the given message.
$warn(string) // Causes the compiler to emit a warning with the given message.

// [MISC]

b := false
assert(type_from(b) == bool) // true
assert(type_of(b) == "bool") // true

c: type_from(b) // c is type bool
assert(type_from(c) == bool) // true
assert(type_of(c) == "bool") // true

num := 42.f
assert(size_of(num) == 4) // true

type Point struct {
    x: f32
    y: f32
}

assert(align_of(Point) == 4) // true

restrict // See https://en.wikipedia.org/wiki/Restrict

fn updatePointers(restrict ptrA: ^int, restrict ptrB: ^int, restrict value: ^int) {
    ptrA^ += value^
    ptrB^ += value^
}

fn updatePointers(restrict ptrA, ptrB, value: ^int) { /- ... -/ }
// It is important to note that if the function is formed like this 'restrict' only applies to ptrA.
fn updatePointers(restrict ptrA, restrict ptrB, restrict value: ^int) { /- ... -/ } // Better

// [WITH] (maybe? not sure how errors would be handled)

// Nifty uses the with statement from Python as a way to open files.
with open(fileName, mode: string) { /- ... -/ }

// In practice...

fn main() {
    with open("test.txt", "w") {
        file.writeln("Yeet")
    }
}

// By default with creates an immutible variable called 'file'.
// The name can be changed.

fn main() {
    with open("test.txt", "w") as testFile {
        testFile.writeln("Yeet")
    }
}

// At the end of the with scope the file is automatically closed.

// With creates an instance of "nsl.file". This does not need to be included for with to work.

// [BUILDING]

// The build file is done with TOML. The default build file name is 'nifty.toml'.

[<TargetName:string>]
name = string 
// Name of the output.
entryPoint = string 
// The file containing 'main()'.
noEntryPoint = bool 
// Set to true to remove the requirement for a 'main()' function. Defaults to false.
noDepreciated = bool 
// Error if a function marked depreciated is used. Disabled by default.
noGoto = bool 
// Error if goto is used. Enabled by default.
debug = bool 
// Compile to debug mode. Disabled by default.
defines = [string] 
// defines = ["name=value", "name2=value2"]
errorOnWarn = bool 
// Treat warnings as errors. Disabled by default.
noWarn = bool 
// Disable warnings. Disabled by default.
optimization = string 
// Sets the optimization level. Options are none, fast, size, debug. 
// Defaults to "fast". Set to 'debug'. if debug mode is enabled.
default = bool 
// Defaults to true in the first target, otherwise false.
noBoundsChecks = bool 
// Disables bounds checking for the entire program. Defaults to false.

/-

nifty new // Interactive dialog to create a new nifty project

nifty build // Builds using the default build file in the current directory.
nifty build [fileName.extension] // Builds using the specified build file or source file.
nifty build [targetName] // Builds using the specified target with the default build file.
nifty build [buildFile]:[targetName] // Builds using the specified target with the specified build file.

nifty run // Takes the same arguments as 'nifty build' but builds and then runs the project.

nifty run prod // Builds an runs using 'nifty.toml' with target 'prod'.
nifty run server:debug // Builds and runs using 'server.toml' with target 'debug'

When not specifying a target the first target is used by default. Targets can optionally be marked
as the default. Only one target may be marked as default at a time.

-/
