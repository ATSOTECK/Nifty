// [TOP]
// [HELLO WORLD]
// [COMMENTS]
// [VARIABLES]
// [TYPES]
// [NAMESPACES]
// [PACKAGES]
// [FUNCTIONS]
// [CONTROL FLOW]
// [BLOCK VALUES]
// [RANGES]
// [DEFER]
// [ARRAYS]
// [SLICES]
// [STRING]
// [MAP]
// [STRUCTS]
// [STRUCT METHODS]
// [BEHAVIORS]
// [TYPE METHODS]
// [ENUMS]
// [OPERATOR OVERLOADING]
// [UNION TYPES]
// [GENERICS]
// [POINTERS]
// [FUNCTION POINTERS]
// [MEMORY]
// [OPTIONAL]
// [RESULT]
// [ERROR HANDLING]
// [TESTS]
// [IMPLICIT CONTEXTS]
// [MACROS]
// [SIGNALS AND SLOTS]
// [ORM]
// [MISC]
// [BUILDING] [CONFIG]
// [KEYWORDS]
// [TODO / IDEAS]

// Nifty is a new systems programming language in development. Nifty aims to be a (relatively) simple
// usable, readable, and fast programming language that can use existing c code.

// Nifty is not an OOP language nor does nifty aim for complete safety.

// This file is an overview of the language and (basically) everything in here is
// subject to change. I am open to suggestions and if anything is unclear let me
// know. This file is much easier to read in vscode with the nifty extension.
// The extension is in the highlighting/vscode folder and you can copy and paste
// it into you vscode extensions folder to install it. You will have to restart
// vscode for it to go into effect.

// This file is meant to describe the nifty programming languiage and will have little to no
// information on the nsl (Nifty Standard Library). That will be described later in other
// files and will likely be an evolving spec.

/-

Naming conventions:

The following naming conventions are my personal preference and are what nifty uses.
These are not enforced by the compiler.

functions:          camelCase
types:              PascalCase
enum values:        PascalCase
variables:          camelCase
macros:             camelCase
macro constants     SCREAMING_SNAKE_CASE
constants:          SCREAMING_SNAKE_CASE
namespace names:    snake_case
keywords:           snake_case
built-in functions: snake_case
built-in types:     snake_case

The following naming conventions ARE enforced by the compiler.

Exports may not start or end with an underscore.
Privates must start with an underscore and can't end with an underscore.
Locals must end with an underscore.

-/

// [HELLO WORLD] ----------------------------------------------------------------------------------

using fmt

fn main() {
    println("Hello, world!")
}

// Semicolons are optional.

// [COMMENTS] -------------------------------------------------------------------------------------

// Single line comments use '//'.
// This is a comment.

/-
    Multiline comments use '/-' and '-/'
    Comments can be nested so the following is valid
-/

/-
    /-
        // bla
    -/
-/

/- Multiline comments can be on just one line too -/

/*
    C-style comments can be used as well and mixed with nifty comments.
*/

/-
    Like so
    /*
        and so
    -/
*/

// Why not just use /* */? I'm lazy, but you do you.

// [VARIABLES] ------------------------------------------------------------------------------------

// Variables are declared with the 'let' keyword.
let x = 12 // int

// The variable declaration operator can be used as well.
x := 12 // int
y := 12.f // f32
y := 12.0 // f64
y := 12.d // f64

// The types are inferred but can be specified.
let x: int = 12
x: int = 12
let y: f64 = 10 // Valid

// If no value is specified the type must be specified
let x // Invalid
let x: int // Valid
x: int // Invalid, value must be given here.
// (Maybe this could be allowed? Don't really like this syntax for normal variables.)

// Immutable variables (runtime constants) are declared with the 'val' keyword.
val x = 12

// The constant declaration operator can be used as well.
x ::= 12

// The type is inferred for constants as well but it can also be specified.
val x: int = 12
x :: int = 12
val y: int // Invalid, immutable variables must have their value specified.

// Variables are auto initialized in Nifty.
let x: int
y := x // Valid, both will be type int with value 0

// Variables can be explicitly uninitialized
let x: int = undefined
x := undefined // Invalid, no type given
x: int = undefined // Valid

// Multiple variables can be explicitly undefined with 'undefined'

undefined {
    let x: int
    let y: float
    let z: string
}

// x, y, and z are all defined but uninitialized.

// It is important to know that undefined is only used for declaring variables. 
// You can't check to see if a variable is undefined.
if (x == undefined) // Invalid
// Because of this undefined is NOT null
undefined == null // Invalid

// A variabled can't be later set to undefined.
x := 12
x = undefined // Invalid

buf: u32 = undefined
bufNum := buf // Valid but undefined behavior. buf could be anything. Should this warn?

// Immutable variables can not be set to undefined.
val y: int = undefined // Invalid, immutable variables must have their value specified.

// Nifty does not support variable shadowing (with the exception of optional pointers).

fn someFunc(x: int) {
    x := 12 // Invalid
}

fn someFunc() {
    someVar := 12
    {
        someVar := 42 // Invalid
    }
}

a, err := someFunc1() // returns int, Error
b, err := someFunc2() // returns f32, Error

// The above is valid. It might look like err is being redefined but it is not. Because err is the
// same type for both functions it is not being redefined, it is just being set the the output.

err := someFunc3() // returns Error
// The above is invalid because err is being redefined.
err = someFunc3() // Valid

// Variables can also be unused.

// Lets say you have a function that returns two ints.
fn returnsTwoInts(): int, int { /- ... -/ }

// But you only care about the 2nd one.
unused, y := returnsTwoInts()

// Because unused is a reserved identifier it can be redefined
unused := someOtherFunc()
unused = someOtherFunc()

// unused can't be constant.
unused ::= anotherFunc() // Invalid

//unused is not a real variable, and thus doesn't have a value.
x := unused // Invalid
fmt::println(unused) // Invalid
type_of(unused) // Invalid

// Variables can have attribues.
#[static]
y := 42 // static variable

#[threadStatic]
x := 12 // thread static variable

// [CONSTANTS] ------------------------------------------------------------------------------------

// Constants use the 'const' keyword and their value must be determined at compile time.
const x = 12
const y = someFunc() // Invalid
const z = #MACRO_CONST // Valid
const w = #constEvalFunc() // Valid

// The constant declaration operator can be used as well.

x ::= 12

// The compiler will differenciate between a runtime constant and a compile time
// constant so the same operator can be used.

// Constants can't be undefined or unused either.

// [TYPES] ----------------------------------------------------------------------------------------

// Basic Types:
char // same width as u32 defaults to '\0'
int // same as s32 defaults to 0
uint // same as u32 defaults to 0
float // same as f32 defaults to 0.f
double // same as f64 defaults to 0.d

uintptr // defaults to 0

// defaults to false
bool // Same as b32?
b8 b16 b32 b64

// defaults to 0
u8 u16 u32 u64 u128
s8 s16 s32 s64 s128

//defaults to 0.0
f16 f32 f64 f128

//defaults to ""
string

// defaults to "\0"
cstring // Null terminated string. Meant for interfacing with c libraries.

typeid // runtime identifier for a type
__anytype // Begins with 2 underscores to show that this is a special type.
// Using __anytype will cause a warning that can be suppressed.

rawptr // Like void* in c, used for compatibility with existing c code.

// Custom types can be created as follows:

typedef Custom as int
let var: Custom
assert(type_of(var) == "Custom") // True

fn takeCustom(c: Custom) { /- ... -/ }
let a: Custom
let b: int
takeCustom(a)
takeCustom(b) // Valid

if (a == b) // Valid

// To force Custom to be distinct from int use the distinct attribute.
#[distinct] typedef Custom as int

takeCustom(a)
takeCustom(b) // Invalid

if (a == b) // Invalid, implicit casting not supported.
if (cast(a, int) == b) //Valid

// A new default value can be given for distinct types.
#[distinct, initTo(1)] typedef Month as int
let month: Month // month is 1

// Casting uses the 'cast' operator.
x: s8 = 100
y := cast(x, s32) // cast(var, type)

// To cast between two types of the same size you can use the 'recast' operator. 
// Like reinterpret_cast in c++.
let x: f32 = 12.0
y := recast(x, u32)

// This is similar to the following pointer cast manipulation:
let x: f32 = 12.0
y := cast(^u32, &x)^

// Though recast doesn't require taking the address of the value which is not always possible.

// There is a third casting operator called 'auto_cast'.
x := 12.f
y := 19
// ...
y = auto_cast(x)

// auto_cast is convienient but potentially unsafe.

y = cast(x, type_from(y)) // Like auto_cast

// Types in nifty are not implicitly converted.

x := 12
y := 42
z: f64 = x / y // Invalid
z: f64 = cast(x, f64) / cast(y, f64) // Valid
z: f64 = cast(x / y, f64) // Valid, but probably not what you want.

// Implicit upcasting is allowed though.
x: f16 = 1.f
y: f32 = x
z: f64 = y

x := 12
if (x) { /- ... -/ } // Invalid
if (x != 0) { /- ... -/ } // Valid

b := true
if (b) { /- ... -/ } // Valid
if (b == true) { /- ... -/ } // Valid

p: ^int = null
if (p) { /- ... -/ } // Invalid 
if (p != null) { /- ... -/ } // Valid

// Nifty supports hex, octal, and binary numbers
x := 0xff // or 0xFF
y := 0q72 // octal uses q because using o is less readable
z := 0b1011011

// Numbers can also have underscores for better readability.
x := 1_000_000
y := 0xFF_AA_12
z := 0xBAD_F00D

// Nifty has raw strings, to use raw string use back ticks.

str := `this\is\'a\raw\string`

// "here strings" could be nice but they are hard to make work with the syntax highlighting.

// [NAMESPACES] -------------------------------------------------------------------------------------

// All nifty programs are made of a collection of namespaces.

namespace main

// Namespaces are used with the 'use' keyword.
use fmt
use math

fn main() {
    fmt::println(math::PI)
}

// If no namespace is specified for a file then the default 'default' namespace is used.

using fmt
use 'foo'

fn main() {
	println("Hello world!")
    foo::bar()
}

// By default the name of the namespace is the last element of the namespace 
// path, which is also the name of the namespace in the file. This, however,
// can be changed with the 'as' keyword

use fmt
use math as M
use math::random

fn main() {
    fmt::println(M::PI) // math::PI is invalid
    fmt::println(random::number())
}

// Note the 'random' is a namespace inside the 'math' namespace and must be used
// separately from 'math'.

// All items inside a namespace can be added to the current scope with the 'using' keyword.

use fmt
using fmt // All items exported from the fmt namespace are now in this file's scope.

fn main() {
    println("Yo whaddup?")
}

// --- --- --- --- ---

use fmt

fn sayHi() {
    using fmt // All items from the fmt namespace are now in this function's scope.
    println("Hello")
}

fn main() {
    fmt::println("Yo whaddup?")   
}

// 'using' can also be used to import the namespace and bring it in to the file scope.
using fmt

fn main() {
    println("Hello world!")
}

// If two namespaces are brought into the same scope and they have any exported symbols
// with the same name then the namespace name must be provided to avoid ambiguity.

use fmt
use "foo"

using fmt
using foo // Lets say that nanespace 'foo' also has a println function.

fn main() {
    println("Ya yeet") // Invalid
    foo::println("Yote") // Valid
}

// Namespaces in the nifty standard library (nsl) or the include directories are used without
// double quotes while user made namespaces are included with double quotes.
use fmt // nsl namespace
use "foo::bar" // non-nsl namespace (user made)

// Specific functions or types can be used from a namespace as well.

use fmt{ println }

fn main() {
    println("Hello world!")
    fmt::print("fmt is still used!\n")
}

// This will still use the fmt namespace but it brings just println into the current scope.
// This can be a good alternative to the 'using' keyword as it decreases the chances of name collisions.

// The 'as' keyword can still be used
use fmt{ println as pln } as F

use math::random{ int64, float64 }

use os::io::file
use os::io::folder

use os::io::{ file, folder } // file and folder are namespaces
use math::random{ int64, float64 } // int64, float64 are functions

use nsl::io
use nsl::mem
use nsl::unicode::utf8{ String }
use nsl::bytes

// Is the same as

use nsl::{ io, mem, unicode::utf8{ String }, bytes }
use nsl::{
    io, 
    mem,
    unicode::utf8{ String },
    bytes
}

// Is the same as

use io
use mem
use unicode::utf8{ String }
use bytes

use "game"::{ map, object } // use game, map, object namepaces
use "game"{ run, quit } // run, quit are functions

use "types.ny" // would this make a namspace "types"? Or would this be the same as using?
// Or should only using be allowed?
using "types.ny"

// When importing specifics like this the 'using' keyword can not be used.

// All items not starting or ending with an underscore are exported from the namepace.

namespace example

let _privateVar: int // Private to the namespace.
let exportedVar: f64
let localVar_: string // Private to the file.

const exportedConst = 100
const _privateConst = 42
const localConst_ = 12

fn _somePrivateFunction() {
    // Do something
}

fn exportedFunction() {
    // Do something
}

fn localFunction_() {
    // Do something
}

typedef _PrivateStruct struct {
    // Stuff
}

typedef ExportedStruct struct {
    // Stuff
}

typedef LocalStruct_ struct {
    // Stuff
}

// etc...

// You might be thinking what if you have
let _someVar_: string
// Then what will happen? In this case the compiler will default to the most private case.
// So _someVar_ will be a local variable (private to the file).
// It is not recommended to start and end with an underscore though and this may generate
// a warning.

// Underscores can be used in variable names in other contexts with no warnings, though it isn't
// always recommended.
fn someFunc(_someVar, secondVar_, _thirdVar_: int) { /- ... -/ } // Nothing special about any of these args.

fn otherFunc() {
    // Stuff
    _x := 12 // Nothing special about _x or x_ or _x_ here.
}

// Sometimes you only want to expose an api for your namespace without exposing the implementation.
// For that you can use the 'api' keyword. A namespace may have at most one api file. All functions,
// structs, variables, etc must be public and must not start or end with an underscore. The idea is
// to be similar to header files in c/c++.
// These files should be named namespace_name.api.nifty For example the api file for the game namespace
// would be game.api.nifty The api file must be in the same folder as the namespace for development.
// Using a namespace with an api file works like using any other namespace.
// Everything listed in an api file must be defined and implemented in the namespace.

// TODO: Should there be an option to generate the api file for a given namespace automatically?
// This would only included exported symbols in the namespace.

api game // The game namespace must be defined and implemented.

use math::matrix // Other namespaces can be used to show that this namespace depends on it. using can be
// used as well.

// Items should be defined as they are in the namespace.
// Otherwise a warning will be issued.

// Functions must not be defined.
fn drawText(x, y: f32, text: string, fontSize: u32, color: Color)
fn createRobot(x, y: f32, health: int): ^Robot
fn doSomethingWithAMatrix(m: matrix::Matrix)

// Invalid, functions can't have implementations.
fn sayHi() {
    fmt::println("hi")
}

// It is ok to redefine structs/enums/behaviors/types in the api file.
typedef Circle struct {
    x, y: f32
    r: int = 100
}

// Even though the functions are not being implemented here the impl, constimpl, and endimpl
// keywords are used here.
impl Circle
    md draw(color: Color)
endimpl

typedef Collection<T> struct { /- snipped -/ }

// The same for generics. (Pretend Collection is defined above, it is defined in [GENERICS] though)
impl Collection<T>
    md init(size := 0)
    md add(num: T)
    md average(): float
endimpl

impl Collection<int>
    md sum(): int
endimpl

// The use of indentation above is optional, I just think it is easier to read this way when there
// is no implementation.

typedef Align enum {
    Vertical,
    Horizontal,
}

// Variables may be defined or undefined. Unlike normal variable declarations variables
// must be explicetly set.
let defaultAlignment = Align.Vertical
let defaultFont: ^Font = undefined
const DEFAULT_FONT_SIZE = 42
// If a variable does not match the definition in the namespace a warning will be issued.

// An option would be to set them to undefined and explain the default in a comment.
/// Defaults to vertical
let defaultAlignment: Align = undefined
/// Defaults to "Comic Sans" aka the font of Champions.
let defaultFont: ^Font = undefined


// Declaration operators can be used as well.
isFullscreen := false

// [PACKAGES] -------------------------------------------------------------------------------------

// Packages are collections of namespaces.

package nsl namespace io

// So the io namespace belongs to the nsl package.

// Packages can be used like a namespace.

use nsl
nsl::os::exit(1)

use nsl::{ os }
os::exit(1)

using nsl::{ os }
exit(1)

using fmt
using nsl::fmt

// Packages can't be used without namespaces.

package engine // Invalid
package engine namespace map // Valid

// Packages are not needed.

namespace map // Valid

// Smaller programs probably have no need for packages but larger more complicated programs should
// probably use them.

// The api keywork can't be used with packages, only with namespaces.

api nsl // Invalid because nsl is a package.

// nsl::math::random
use nsl::math::random
math::PI
random::int64()

// [FUNCTIONS] ------------------------------------------------------------------------------------

// Functions are declared with the 'fn' keyword.

fn someFunc() {
    // Do something
}

// Functions can have arguments.
fn sayHi(name: string) {
    fmt::println("Hi", name)
}

// ...and return types
fn add(a: int, b: int): int {
    return a + b
}

// ...and multiple return types
fn openFile(name: string): File, bool {
    // do stuff
}

fn someFunc(): int, float { /- ... -/ }
a, b := someFunc() // Valid
a := someFunc() // Invalid
a, unused := someFunc() // Valid
unused, b := someFunc() // Valid

// It is important to note that if unused is used like this the value is still being passed from the
// function. If this usecase is common and performance is critical then it is recommended to make
// another function that excludes that return value. (or could this be optimized away with the fast
// option by creating and calling modified copies of the function that omit that specific return?)

// If two or more consecutive arguments have the same type, the type can be omitted for all but the
// last argument of that type.
fn add(a, b: int): int {
    return a + b
}

// Functions can have default arguments
fn add(a := 10, b := 10): int {
    return a + b
}

// Here type inference was used for the argument types but they can be specified as well.
fn add(a: int = 10, b: int = 10): int {
    return a + b
}

// Non-default arguments can't come after default arguments.

// Invalid
fn add(a := 10, b := 10, c: int): int {
    return a + b + c
}

// If a function returns something the type must be specified in the function definition.
// A function can be explicitly marked as not having a return value. This is purely for the
// programmers convenience, there is no difference to the compiler. 

fn yeet(): void {
    fmt::println("Yeet")
}

// Function argument names can be used.
fn someFunc(start, stop: int) { /- ... -/ }

someFunc(start: 0, stop: 100) // Named arguments must still be in the order they were defined in.
someFunc(stop: 100, start: 0) // Invalid
someFunc(start: 0, 100) // Valid, the order is preserved so the compiler knows 100 is stop.
someFunc(theStart: 0, theStop: 100) // Invalid, names must match the prototype definitions.

// All function arguments are immutable.
fn someFunc(x: int) {
    x = 12 // Invalid
    y := &x // Invalid
}

// If you need to change the argument for some reason you must either make a copy or use the 'let' keyword.
fn someFunc(x: int) {
    newX := x
    newX = 12 // Valid
}

// Explicitly mark x as mutable with the 'let' keyword.
fn someFunc(let x: int) {
    x = 12 // Valid
    y := &x // Valid
}

// Pointers can also be used to change the value.
fn someFunc(x: ^int) {
    newX := x
    newX^ = 12
}

let x: ^int = new int
x^ = 2
someFunc(^x) // See section on pointers for an explination.
// x is now 12

// varargs
// Functions can be variadic, meaning they can take a variable number of arguments.
// The variadic argument can be treated like a static array.
fn sum(nums: ..int): int {
    res := 0
    for (val n in nums) {
        res += n
    }
    
    return res
}

sum()
sum(1)
sum(1, 2, 3)
sum(4, 5, 6, 7, 8)

// If a variadic function requires a minimum number of arguments to work, that can be specified with minArity(int).

#[minArity(2)]
fn sum(nums: ..int): int {
    res := 0
    for (val n in nums) {
        res += n
    }
    
    return res
}

sum() // Invalid
sum(2, 2) // Valid

// maxArity(int) can also be used.
// Did you know that a function with 9 arguments is called Novenary? Well now you do!

// Arguments can't come after a variadic argument.
fn counts(cnts: ..int, type: string) // Invalid

// Nifty has function overloading, but it works differently compared to languges like c++.
// Instead of two functions having the same name but different arguments the functions have
// different names and are explicetly overloaded. For instance if you had a pow function for
// int, float, and double it might look like this:

fn powi(x: int, y: int): int { /- ... -/ }
fn powf(x: float, y: float): float { /- ... -/ }
fn powd(x: double, y: double): double { /- ... -/ }

fn pow overloads {powi, powf, powd}

// This is done to be more explicit and searchable as well as making the compiler simpler to develop.

// The original functions can still be called or the overloaded function can be called.
a := 2.f
b := 8.f
x := 2
y := 8

z := powi(x, y)
w := pow(x, y) // Calls powi()
v := pow(a, b) // Calls powf()
u := powf(a, b)

// The following will not compile:

fn pow(x: int, y: int): int { /- ... -/ }
fn pow(x: float, y: float): float { /- ... -/ }
fn pow(x: double, y: double): double { /- ... -/ }

// Sometimes you want to guarantee the return variable is handled.
// useReturn can be used to force the return variable to be used.
// Equivalent to [[nodiscard]] in c++.

#[useReturn]
fn returnsError(): Error {
    // do stuff
}

// This will force the caller to handle the returned error.

// Do something
returnsError() // Invalid
// Do more things

// Do something
err := returnsError() // Invalid, err isn't being used.
// Do more things

// Do something
err := returnsError() // Valid
if (err.occured()) {
    // Handle error.
}
// Do more things

// unused can be used to ignore return values from functions marked with useReturn.
unused := returnsError() // Valid

// Should unused be allowed to work with error (or Result) returns? Probably? Not all errors are
// important. Maybe a warning could be emitted if unused is used on functions that return an error
// (or Result).

// Should I have a keyword for this like use_fn/use_md? Probably not.

// Functions can have preconditions or postconditions.
// Preconditions use the require attribute.
#[require {x > 0 && x < 1_000} ensure {return > 0}]
fn someFunc(x: int): int {
    return x * 10
}

// Postconditions use the ensure attribute.
#[ensure {return <= a && return <= b}]
fn min(a, b: s32): s32 {
    if (a < b) {
        return a
    }
    return b
}

// Note that the attributes in the form attribute{code} are to catch compiletime errors and are not
// available via reflection. User attributes can't be in the form of attribute{code}.

// Where possible require and ensure will be checked at compiletime. In debug mode asserts will be
// added to catch runtime require/ensure errors.

// In debug mode the above two functions would effectively be:
#[require {x > 0 && x < 1_000}, ensure{return > 0}]
fn someFunc(x: int): int {
    assert_db(x > 0 && x < 1_000)
    _return := x * 10
    assert_db(_return > 0)
    return _return
}

#[ensure {return <= a && return <= b}]
fn min(a, b: s32): s32 {
    if (a < b) {
        _return := a
        assert_db(_return <= a && _return <= b)
        return _return
    }
    _return := b
    assert_db(_return <= a && _return <= b)
    return _return
}

// This can be used for optimizations.

fn example(n: int): int {
    if (someFunc(n) == 0) {
        return -1
    }
    return 1
}

// can be optimized to

fn example(n: int): int {
    return 1
}

// Because someFunc() can never return 0.

// For functions that take pointers, paramater attributes can be used to control the dataflow.
#[in("a"), inout("b"), out("c")]
fn takesPtrs(a, b, c: ^int) { /- ... -/ }

// in disallows writing to the pointer.
// out disallows reading from the pointer.
// inout allows reading and writing and is the default.

// Note that if in is used and the pointer is passed to second function that second function may be
// able to write to the pointer unless it also has the 'in' restriction. 'in' only guarantees that
// the function it is applied to won't directly write to the pointer. Same issue with 'out'.

// Functions can be inlined with the 'inline' attribute.
#[inline]
fn smallFastFn() { /- ... -/ }
// Or explicetly not inlined with the 'noInline' attribute.
#[noInline]
fn bigSlowFn() { /- ... -/ }
// Let the compiler decide if it should be inlined or not. This is the default, but can be explicetly stated.
#[maybeInline]
fn someOtherFn() { /- ... -/ }

// Function calls can also be inlined.
fn someFunc(): int { /- ... -/ }

fn otherFunc() {
    x := #[inline] someFunc()
}

// someFunc() is inlined in otherFunc()

// Functions can have one or more attribues.
#[attribName, attribName2(value)]
fn bar() { /- ... -/ }

#[deprecated("Function 'foo' is deprecated, use 'bar' instead.")]
fn foo() { /- ... -/ }

#[deprecated("DO NOT USE")]
fn badFunc() { /- ... -/ }

// With deprecatedAfter the deprecated warning will onlt be shown after the given date.
#[deprecated("Use X instead."), deprecatedAfter("2023-10-20")] // yyyy-mm-dd
fn eventuallydeprecated() { /- ... -/ }

// deprecatedAfter can be used on its own. The equivalent of using deprecated with no message specified.
#[deprecatedAfter("2023-10-20")] // yyyy-mm-dd
fn eventuallydeprecated() { /- ... -/ }

#[warning("ABANDON ALL HOPE YE WHO ENTER HERE")]
fn reallyBadFunc() { /- ... -/ }

#[useReturn, maybeUnused]
fn bla(): int { /- ... -/ }

// optionalOk allows skipping the last return value which must be a bool.
#[optionalOk]
md get(key: string): int, bool {
    // Code here ...
    
    if (!found) {
        return 0, false
    }
    
    return value, true
}

var := container.get("thing") // Valid

// Custom attributes can be used as well as attributes provided by the compiler.
// For instance routing for a webserver backend.

#[route("/user/:id"), method("get")]
fn getUserForId(id: string): User! {
    return // Return code here.
}

// Without the suppress this function would cause a warning.
#[suppressWarning("no_anytype")] 
fn someFunc(thing: __anytype) {
    // ...
}

// See the result section for information on what User! means.

// In the web namespace it would be able to look at the attributes attached to this function using
// reflection and be able to do what it needs to do.

// Built-in function attributes.
/- 
useReturn
optionalOk
minArity(argc: int)
maxArity(argc: int)
deprecated(msg: string = "")
deprecatedAfter(date: string) // yyyy-mm-dd
maybeUnused
warning(msg: string)
static // Like static in c/c++.
requireTargetFeature(feature: string)
noReturn
asmReturn // Indicates that the function returns via inline assembly instead of a return statement.
inline
noInline
maybeInline
noContext
traceVars(names: ..string) // Prints the values of the variables listed every time they change.
                           // This is meant for debugging and will be relatively slow.

signal
slot

// Called at the end of the callers scope.
deferredIn(function: fn) // Receives the same paramaters as the called function.
deferredOut(function: fn) // Receives the results of the called function.
deferredInOut(function: fn) // Receives both the input and output of the called function.
deferredNone(function: fn) // Receives no input.
These can be useful but are not always recommended as they can make it not obvious why a function
is being called without further investigation. May get rid of these.

linkName(name: string)

require {code}
ensure {code}
in(vars: ..string)
out(vars: ..string)
inout(vars: ..string)
-/

#[linkName("llvm.cos.f64")]
fn cosf64(f64): f64 undefined

// [CONTROL FLOW] ---------------------------------------------------------------------------------

// For loops work much like they do in c/c++

for (let i = 0; i < 10; ++i) {
    // Do something
}

for (i := 0; i < 10; ++i) {
    // Do something
}

// But aslo have ranges

for (0 ..= 10) { /- ... -/ } // [a, b]
for (0 ..< 10) { /- ... -/ } // [a, b)
for (0 ..= 10; 2) { /- ... -/ } // Uses a step of 2 instead of 1
for (val i in 0 ..< 10) { /- ... -/ }
for (val i in 0 ..= 10; 2) { /- ... -/ } // Uses a step of 2 instead of 1
for (val str in strings) { /- ... -/ }
for (val str, index in strings) { /- ... -/ }
for (let str in strings) { /- ... -/ }
for (val key, value in map) { /- ... -/ }
for (val key, value, index in map) { /- ... -/ }

for (10 ..< 0) { /- ... -/ } // Does nothing

// To go backwards over a range use <
for <(10 ..< 0) { /- ... -/ }
for <(val str in strings) { /- ... -/ }
for < 10 .. <0 { /- ... -/ }

// While loops work like they do in c/c++.

while (condition == true) {
    // Do something
}

// For a do ... while loop use #[atLeastOnce]
#[atLeastOnce]
while (condition == true) {
    // Code ran at least once
}

// Until loops. The opposite of while loops. AKA while (!(condition == true))

until (condition == true) {
    // Do something
}

// For a do ... until loop use #[atLeastOnce]
#[atLeastOnce]
until (condition == true) {
    // Code ran at least once
}

until (window.shouldCLose()) {
    // Game loop.
}

// Is the same as
while (!window.shouldClose()) {
    // Game loop.
}

// When statements are much like switch statements in c/c++ except they only need one dedicated
// keyword.

x := 2
when (x) {
    1: fmt::println("one")
    2: fmt::println("two")
    3: fmt::println("three")
    else: fmt::println("???")
}

// Multiple cases can be handled at once.

when (x) {
    1, 3, 5, 7, 9: fmt::println("odd")
    2, 4, 6, 8, 10: fmt::println("even")
    else: fmt::println("???")
}

// Ranges can also be used.

when (x) {
    in 0 ..< 10: fmt::println("0 ..< 10")
    in 10 ..= 100: fmt::println("10 ..= 100")
    else: fmt::println("big")
}

// By default cases do not fall through. To fall through use '=>'.

x := 2
when (x) {
    1: fmt::println("one") =>
    2: fmt::println("two") =>
    3: fmt::println("three")
    else: fmt::println("???")
}

// The above when statement will trigger 2 and 3.

// When is not just limited to numbers.

str := "one"
when (str) {
    "one": fmt::println("1")
    "two", "three": fmt::println("2 or 3")
    else: fmt::println("???")
}

strs0 := []string{"one", "two", "three"}
strs1 := []string{"four", "five", "six"}
str := "two"

when (str) {
    in strs0: fmt::println("1, 2, or 3")
    in strs1: fmt::println("4, 5, or 6")
    else: fmt::println("???")
}

// Each case in a when statement has its own scope. Curly braces can be used but are not required.

str := "one"
when (str) {
    "one":
        x := 1
        fmt::println(x)
    "two":
        x := 2
        fmt::println(x)
    else: fmt::println("???")
}

// When statements don't always need to have an else: but it is a good idea to have them.
// else: works a bit differently if using when on an enum. See the enums section for an explanation.

// If statements. Work how they do in c/c++ with the addition of elif.

if (thing) {
    // Do something 1
} else if (thing2) {
    // Do something 2
} elif (thing3) {
    // Do something 3
} else {
    // Do something 4
}

// Logic operators work the same as in c/c++.
// && for and
// || for or
// ! for not
// | bit or, & bit and, ~ bit xor(binary), ~ bit not(unary), << lsl, >> lsr

// Ternary operator. Ternary operators can't be nested.

valueIfTrue ::= 12
valueIfFale ::= 42
condition := true
x := condition ? valueIfTrue : valueIfFale
assert(x == 12) // true

condition = false
x = condition ? valueIfTrue : valueIfFale
assert(x == 42) // true

// Labels are defined with #labelName!
#someLabel!

// Labels can be used with continue, break, and goto.
// Yes nifty has goto, however use of goto is disabled by default. Misuse of goto can quickly cause
// messy code but it can be very powerful in specific senarios. So I see no reason not to include it.

#forever!
// Code
goto #forever!

// goto can't jump to labels in other functions.

// Continue and break

for (i := 0; i < 10; ++i) {
    if (i % 2 == 0) {
        fmt::println("even")
        continue // Will exit this loop and continue the loop.
    }
    
    fmt::print("odd")
}

found := false
for (val v in someArray) {
    if (v == target) {
        found = true
        break // Will exit this loop but will not continue the loop.
    }
}

// Labels can be used with break and continue as well. For instance if you have and inner and
// outer loop you can use labels to specify which loop to break/continue from. Otherwise
// nifty will break/continue from the loop the statement is in which may not be what you want.

#outer!
for (i := 0; i < 100; ++i) {
    #inner!
    for (j := 100; j >= 0; --j) {
        if (someCondition) {
            continue #inner!
        }
        
        if (otherCondition) {
            break #outer!
        }
        
        // Stuff
    }
    
    // Stuff
}

// [BLOCK VALUES] ---------------------------------------------------------------------------------

// Blocks are expressions and can be used to get values.

count := {
    let sum: u32
    for (i: u32 = 0; i < 10; ++i) {
        sum += 1
    }
    <- sum // The <- "returns" sum.
}

// Sometimes it's impracticle or not possible to initialize/set a variable in one line. Using
// blocks can prevent needing to set the variable to undefined or a temporary value.

// Blocks can be labbeled as well to return a value from a specified block if nested.

x := aNumber()

count2 := #outerBlock! {
    let sum: u32 = #innerBlock! {
        for (i: u32 = 0; i < 10; ++i) {
            sum += 1
        }
        
        if (x > 20) {
            <- #outerBlock! sum
        }
        
        <- #innerBlock! sum
    }
    
    for (i: u32 = 0; i < 10; ++i) {
        sum += 1
    }
    <- sum
}

// [RANGES] ---------------------------------------------------------------------------------------

1 ..= 5 // [1, 5] 1, 2, 3, 4, 5
1 ..< 5 // [1, 5) 1, 2, 3, 4

range := 0 ..= 10 // type range
x := 12

if (x in range) {
    // Do something
}

for (val v in range) {
    fmt::println("v ", v)
}

fmt::println(range.low, ", ", range.high) // 0, 10

// Maybe? Not sure if I want a range type or not.

// [DEFER] ----------------------------------------------------------------------------------------

// 'defer' defers the execution of code until the end of the current scope.

fn someFunc() {
    // stuff
    someFile.open("myFile.txt")
    defer someFile.close()
    // more stuff
}

// Blocks of code can be deffered as well.

fn anotherFunc() {
    defer {
        call1()
        if (condition) {
            call2()
        }
    }
    // stuff
}

// Defer statements can be stacked as well and are executed in a First In Last Out (FILO) fashion.

namespace main
using fmt

fn main() {
    for (val i in 0 ..< 5) {
        defer println(i)
    }
    println("Hello world")
}

/- Will print the following:
Hello world
4
3
2
1
0
-/

// Nifty has a second type of defer, defer_err. defer_err only runs if the function returns an error.
// This can only be used in function that returns a Result. This is because if the function returns
// an Errorable then it would always be called because the function would always have to return an
// Errorable. In that case defer should be used. defer_err is run in a FILO fashion as well.

// defer_success
fn someFunc(str: string): ^Value! {
    someVar := new Value(str)
    defer_err delete someVar
    
    if (someVar->count() < 10) {
        return Error("count() is less than 10!") // defer_err is run here.
    }
    
    if (someOtherCondition) {
        return Error("Some other condition was met!") // defer_err is run here.
    }
    
    // defer_err is not run here.
    return someVar
}

// See the Result section for an explanation on ^Value!.

// [ARRAYS] ---------------------------------------------------------------------------------------

// Static arrays
let arr: [5]int // Array of 5 integers, auto initialized to [0, 0, 0, 0, 0]
arr := [5]int{1, 2, 3, 4, 5} // Array of 5 integers initialized to [1, 2, 3, 4, 5]
arr := [?]int{1, 2, 3, 4, 5} // Array of 5 integers where the length is inferred.
arr := [1, 2, 3, 4, 5] // Array of 5 integers where the length and type are inferred.
arr := [5]int{5} // Array of 5 integers initialized to [5, 5, 5, 5, 5]
arr := [5]int{5, 6} // Array of 5 integers initialized to [5, 6, 0, 0, 0] or should this not compile?
arr: [5]int = undefined // Array of 5 integers not initialized to anything.

// Dynamic arrays
let arr: []int // Array with length 0 and capacity 0
arr := []int{} // Array with length 0 and capacity 0
arr := []int{cap: 100} // Array with length 0 and capacity 100 initialized to []
arr := []int{len: 3, cap: 100} // Array with length 5 and capacity 100 initialized to [0, 0, 0]
arr := []int{len: 3, cap: 100, init: 2} // Array with length 5 and capacity 100 initialized to [2, 2, 2]

arr := []int{len: 10, cap: 0} // Invalid, cap must be >= length

// Note that static arrays all have their cap specified (or use ?) inside [], or are directly set via [].
// Dynamic arrays always have [] left blank. Dynamic arrays are also set differently.
arr := []int{1, 2, 3} // Invalid. Dynamic arrays can't be set like this.
arr: []int = [1, 2, 3] // Valid, dynamic.
arr: [?]int = [1, 2, 3] // Valid, static.

// Arrays created with the new keyword are dynamic
arr := new [5]int // Dynamic array with length 0, capacity 5
arr := new [n]int // Dynamic array with length 0, capacity n
arr := new []int  // Dynamic array with length 0, capacity 0
arr := new [?]int // Invalid.

// Arrays are 0 indexed.
arr := [1, 2, 3, 4, 5]
x := arr[0] // x is 1
arr[2] = 12 // [1, 2, 12, 4, 5]

// Arrays are bounds checked at compile time (where possible) and runtime.
// Nifty can be set to only bounds check in debug mode.
x := arr[5] // Compile time error.
arr[12] = 42 // Compile time error.

y := 5
x := arr[y] // Runtime error.

// Runtime bounds checking can be disabled at a block level with #noBoundsCheck
// This can be important in situations where performance is critical. Could lead to undefined behavior.
#noBoundsCheck {
    x = arr[y] // y could still be out of bounds.
}

// To get the length of an array use the included len() function.
assert(arr.len() == 5) // true
// To get the capacity of an array use the included cap() function.
assert(arr.cap() == 5) // true
// To get the number of open slots in an array use the included slots() function.
assert(arr.slots() == 0) // true

arr := []int{len: 5, cap: 100, init: 12} // [12, 12, 12, 12, 12]
assert(arr.len() == 5) // true
assert(arr.cap() == 100) // true
assert(arr.slots() == 95) // true

// To append to an array use the included append() function.
// Will error on static arrays.
arr.append(4) // [5, 5, 5, 5, 5, 4]
// Multiple values can be appended at once.
arr.append(6, 7, 8, 9) // [5, 5, 5, 5, 5, 4, 6, 7, 8, 9]
arr.prepend(12) // [12, 5, 5, 5, 5, 5, 4, 6, 7, 8, 9]

arr.clear() // []

// Arrays can be multidimensional.
let arr: [][]int // 2D array of int
arr := {
    {1, 2, 3, 4},
    {5, 6, 7, 8}
}

arr[1][2] // 7
arr[0] // [1, 2, 3, 4]

// [SLICES] ---------------------------------------------------------------------------------------

// Slices are like arrays but can be more accurately thought of as a view into the array.
// A slice is created by specifying the start index and the end index.

array[low : high]

array := [1, 2, 3, 4, 5, 6, 7]
arr := array[1:4] // Includes elements 1 through 3. [2, 3, 4]

// The following expressions are all equivalent.
array[0:7]
array[:7]
array[0:]
array[:]

// Slice literal.
slice := [:]int{1, 2, 3} // Creates an array with [1, 2, 3] then creates a slice for it

// Slices have length, size and capacity.
arr := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
slice := arr[1:5] // [1, 2, 3, 4]

slice.len() // 4
slice.size() // 4
slice.cap() // 0

newSlice := slice[0:20] // Compiler error. End is out of bounds of the array.

arr := [5]int{0} // [0, 0, 0, 0, 0]
slice := arr[1:5] // [0, 0, 0, 0]

slice[0] = 12 // slice is now [12, 0, 0, 0] arr is now [0, 12, 0, 0, 0]

// [STRING]

str := "hello " ## "world" // String concatination.

str.len()
str.size()

// [MAP] ------------------------------------------------------------------------------------------

// Nifty has a built-in map type. I think this should just be in the nsl instead of built-in.
// This should also return Optional<T> instead of T, bool.
// TODO: Rewrite this for nsl eventually.

m := map<string, int>() // The default value of a map is an empty map.
defer delete m
m["Alice"] = 12
fmt::println(m["Alice"]) // Prints 12

// To insert or update a value use
m[key] = value
 
// To get a value use
value = m[key]

// If the keey is not in the map then the default value of the type is returned.
m := map<string, int>()
i := m["index"] // i will be 0

// Checking if the key exists can be done in two ways:
m := map<string, int>()
if (i, ok := m["index"]; ok) { /- ... -/ } // i will be 0, ok will be false

// or

ok := "index" in m // ok will be false
if (ok) { /- ... -/ }

// The first example is the comma ok idiom from go and is the same as:
i, ok := m["index"]
if (ok) { /- ... -/ }

// Maps can be initialized with map literals.

m := map<string, int>{
    "Alice": 12,
    "Bob": 42
}

m := map<string, int>{} // Valid, empty map
let m: map<string, int> // Valid, empty map
m := map<string, int>() // Valid, empty map

// len() can be used to get the number of items in a map
assert(m.len() == 2) // true

// To remove a key/value pair use the 'remove' function:
m.remove(key)

typedef Point struct { x, y: f64 }
m := map<string, Point>{
    "zero": {},
    "start": {12.f, 42.f},
    "stop": {142.f, 96.f}
}

// Because the value type is specified it is ok to not include the name of the fields.
// Though it can be included.

m := map<string, Point>{
    "zero": Point{},
    "start": Point{12.f, 42.f},
    "stop": Point{x: 142.f, y: 96.f}
}

// [STRUCTS] --------------------------------------------------------------------------------------

typedef Point struct {
    x: int
    y: int
}

let p: Point
p.x = 12
p.y = 42

point: Point = {x: 12, y: 42} // Valid
point: Point = {12, 42} // Valid
point: Point = {} // Valid, x and y are set to 0, same as let point: Point
point: Point = {12} // Invalid, either all values must be set or no values are set
point := Point{x: 12, y: 42} // Valid
point := Point{x: 12} // Valid, y is 0
point := {x: 12, y: 42} // Invalid, other types could have an x and y.

// Default values can be given for strcut fields.

typedef Point3D struct {
    x: f64 = 100.f
    y: f64 = 100.f
    z: f64 = 1.f
}

// This allows structs to be uninitialized.

typedef Point3D struct {
    x: f64 = undefined
    y: f64 = undefined
    z: f64 = undefined
}

// Default values can be blocked when declaring the variable.

typedef Point struct {
    x: int = 12
    y: int = 42
}

let p: Point = undefined
x := p.x // Undefined behavior, x can be anything.

typedef Point struct: undefined {
    x: int = 10
    y, z: int
}

// or should it be ???

#[undefined]
typedef Point struct {
    x: int = 10
    y, z: int
}

// y and z will default to undefined while x will default to 10

// Fields on a struct can be marked as required. Meaning that field must be specified when creating
// an instance of the struct.
typedef Foo struct {
    bar: int #[required]
    baz: int
}

foo := Foo{} // Invalid
foo := Foo{bar: 100} // Valid
foo := Foo{bar: 100, baz: 200} // Valid

// If fields in a struct are of the same type then they can be on the same line.

typedef Point3D struct { x, y, z: f64 }
point := Point3D{y: 12.f, Z: 42.f} // Valid

// You can also set fields on the same line to the same value.
typedef Point3D struct { x, y, z: f64 = 100.f }
typedef Point3D struct { x, y, z: f64 = undefined }

// Nifty supports embedded structs.
typedef Size struct { w, h: int }
typedef Position struct { x, y: f32 }

// Size and Position are embedded into Button
typedef Button struct {
    ...Size
    ...Position
    title: string
}

button := Button{x: 100, y: 100: w: 256, h: 64, title: "Yeet"}

// Spread operator on struct instances.
typedef Person struct {
    name: string
    age: int
    job: string
}

fn assignJob(person: Person, job: string): Person {
    return Person{
        ...person,
        job: job
    }
}

p := Person{name: "Joe", age: 27}
p = assignJob(p, "Programmer")
fmt::println(p.job) // Programmer

// structs can have read only fields by using the const keyword.

typedef Config struct {
    const host: string  // Must be set on int, can't be changed.
    const port: string  // Must be set on int, can't be changed.
    name: string
}

typedef Config struct { const host, const port, name: string }

cfg := Config{} // Invalid
cfg := Config{host: "::", port: "7777"} // Valid

// Struct pointer ownership

// Adding @ to the end of a pointer type type indicates that the object pointed to is owned by the
// struct and should be deleted when the struct is deleted.

typedef Node struct { left, right: ^Node@ } // left and right are automatically deleted when the
                                         // struct object is deleted.

// Structs can also have attributes.

#[packed] // Will not add padding
typedef Packed struct {
    x: f64
    y: s16
}

// Preconditions can be stated. Where possible this will be checked at compile time. In debug mode
// asstert_db statements will be inserted to verify the precondition.

#[require {min <= max}]
typedef Range struct { min, max: int }

range := Range{2, 1} // Invalid

range := Range{x, y}
assert_db(range.min <= range.max) // Added if in debug mode.

/- Built-in struct attributes
packed
align(alignment: int)

require {code}
-/

// Attributes can be applied to struct fields as well.

typedef Person struct {
    id:        int        #[json("id"), norm("index")]
    name:      string     #[json("name")]
    holding:   []string   #[json("holding"), omitempty]
    createdAt: time::Time #[json("created_at")]
}

// [STRUCT METHODS] -------------------------------------------------------------------------------

// For methods the md keyword is used so that if the impl keyword is missed by a 
// programmer or a programmer jumps to the middle of the file it is obvious that
// these are methods and not ordinary functions. The fn keyword can be used as 
// well if preferred. The md keyword can't be used outside an impl.

typedef Collection struct {
    list: []int
    _average: float // Private variable
}

impl Collection

// Nifty does not have constructors/destructors.

md init(size := 0) {
    list = []int{size: size}
}

md add(num: int) {
    append(list, num)
    _calculateAverage()
}

// Functions can be marked as read only, meaning they can't modify the struct at all.
#[readOnly]
md average(): float {
    return _average
}

// Private function
md _calculateAverage() {
    total := 0
    for (val num in list) {
        total += num
	}

	average = cast(total, f32) / cast(list.len(), f32)
}

endimpl

// Optionally the name of the struct can be specified with endimpl.
endimpl Collection
// This is just to improve readability in files with multiple struct implementations.
// This does not allow for impl nesting.

collection := Collection{}
collection.init(100)

collection := new Collection{ /- ... -/ } // Type is ^Collection. 
// The values can be specified.
collection := new Collection // Invalid
collection := new Collection{} // Valid

// To make collection an optional pointer:
let collection: ^Collection? = new Collection{}
// Or more succinctly
let collection? = new Collection{}
collection? := new Collection{}

collection := new Collection{list: []int{}} // Private variables can't be set here.

collection->add(12) // Valid
// Is effectively the same as (but is not the same as)
add(collection, 12) // Invalid

// The calling object is implicetly passed in like 'this'.

collection = null
collection->add(12) // The function add will not be called. This will panic.

if (collection != null) {
    collection->add(12) // No error.
}

// If you don't allocate the object on the heap this is not an issue.

collection := Collection{list: []int{}} // Type is Collection.
collection := Collection // Invalid
collection := Collection{} // Valid
collection.add(12)

// You may have noticed that I used both '->' and '.' when calling the 
// functions. Nifty works like c++ in that objects that are pointers use 
// '->' and objects that are not pointers use '.'. This is to visually 
// distinguish the two.

// A struct can be implemented multiple times. So for instance a struct could exist in a library
// and you could extend it in you own code.

namespace some_lib

typedef SomeStruct struct {
    // ...
}

impl SomeStruct
// ...
endimpl

// Somewhere in your code:

use "some_lib"

impl some_lib::SomeStruct
// Your code ...
endimpl

// To prevent this the 'constimpl' keyword can be used.

constimpl SomeStruct
// ...
endimpl

// Your code ...

impl some_lib::SomeStruct // Compiler error.

// Multiple constimpl can be used within the orginal file the struct is defined in. 
// With generics there are cases where it may make sence to have seperate implementations
// for different types.

// To print a struct type use the fmt::Printable behavior.

typedef Color struct { r, g, b: u8 }

impl Color does fmt::Printable

md str(): string {
    return fmt::sprintf("{}, {}, {}", r, g, b)
}

endimpl

color := Color{51, 153, 255}
fmt::println("The color is {}.", color)

// Not sure if next section is worth the complexity or should 'this' or 'self' just be passed 
// implicitly if used by the function.

// When implementing functions on a struct the structs fields are implicitly available to the
// function body. Optionally functions implemented on a struct can have a receiver argument. The
// receiver argument is in brackets right before the functions parentheses. The struct type name
// can be used for the type.

typedef Thing struct {
    x: int
}

impl Thing

md yeet[this: ^Self]() {
    this->x = 12
    x = 42 // Invalid
}

md yert[this: ^Thing]() {
    this->x = 12
    x = 42 // Invalid
}

md yote(newX: int) {
    x = newX
    this->x = newX // Invalid
}

// Pass receiver by value.
md printX[t: Thing]() {
    fmt::println(t.x)
    t.x = 12 // Invalid
}

// Pass receiver by mutable value.
md localSetX[let t: Thing]() {
    fmt::println(t.x)
    t.x = 12 // Valid, but done on a copy of the receiver argument.
}

md readOnlyPtr[const this: ^Self](n: int) {
    this->x = n // Invalid
}

endimpl

// The functions are called the same as any other.
let thing: Thing
thing.yeet()
thing.yert()
thing.yote(12)
thing.printX()

// [TYPE METHODS] ---------------------------------------------------------------------------------

// Methods can be added to any type.

#[distinct, initTo(1)] typedef Month as int

impl Month does fmt::Printable

md str[m: Month](): string {
    when (m) {
        1: return "January"
        2: return "February"
        // etc...
        else: return "???"
    }
}

endimpl

let month: Month
fmt::println(month) // Prints January.
month++
fmt::println(month) // Prints February.

// Maybe this should not apply to built in types.

impl int

md isEven[n: int](): bool {
    return ~n & 1
}

endimpl

let x = 12
// ...
if (x.isEven()) {
    // Do something.
}


// [BEHAVIORS] ------------------------------------------------------------------------------------

// Behaviors are a a way to define shared behavior. To indicate that an implementation does a
// certain behavior the 'does' keyword is used. Implementations can do one or more behaviors.

// If an implementation does a behavior then all the functions in the behavior must be 
// implemented or there will be a compiler error. If an implementation does multiple behaviors
// with conflicting function names then there will be a compiler error. If a behavior and an
// impl have conflicting function names there will be a compiler error. Or should it require 
// prefixing with the BehaviorName.

use math

typedef Rect struct { w, h: f64 }
typedef Circle struct { r: f64 }

typedef Geometry behavior {
    area(): f64
    perim(): f64
    kind: string
}

typedef Arc behavior {
    partialArea(percent: f64): f64 // The argument name is optional here.
    partialArea(f64): f64 // The same
}

impl Rect does Geometry

md area(): f64 {
    return w * h
}

md perim(): f64 {
    return 2 * w + 2 * h
}

endimpl

impl Circle does Geometry, Arc

md area(): f64 {
    return math::PI * r * r
}

md perim(): f64 {
    return 2 * math::PI * r
}

md partialArea(percent: f64): f64 {
    return area() * percent
}

endimpl

rect := Rect{100, 100, "rect"}
circle := Circle{10, "circle"}

fmt::println(rect.kind) // Because Rect does Geometry it "inherits" the kind variable. 
// I use the word inherits here but that is not entirly correct. The kind variable gets added to
// the end of the implementing struct in the order the behaviors were listed at compile time.
// Or should it be at the beginning? Should this be configurable?

// Behaviors can be used as parameters to define a function that can take many types that all share
// that behavior.

fn printArea(shape: does Geometry) {
    fmt::println(shape.area())
}

// printArea accepts any type that does Geometry.

// This is the same as the above.
fn printArea<typedef T: Geometry>(shape: T) {
    fmt::println(shape.area())
}

// This function is fine and allows for shape1 and shape2 to be different types.
fn printAreas(shape1, shape2: does Geometry) { /- ... -/ }
fn printAreas<typename T: Geometry, typename U: Geometry>(shape1: T, shape2: U) { /- ... -/ } // Same as above.

// To require that shape1, and shape2 be the same type
fn printAreas<typename T: Geometry>(shape1, shape2: T) { /- ... -/ }

// Multiple behaviors can be required.
fn printAreaAndShape(shape: does Geometry & fmt::Printable) {
    fmt::println(shape.area())
    fmt::println(shape)
}

fn printAreaAndShape<typename T: Geometry & fmt::Printable>(shape: T) { /- ... -/ }

// This works for structs as well.
typedef Shape struct {
    geometry: does Geometry
    otherVar: int
}

// Is the same as:
typedef Shape<typename T: Geometry> struct {
    geometry: T
    otherVar: int
}

// Behaviors can be combined into new behviors via type intersections.

typedef PrintableGeometry as Geometry & fmt::Printable

impl Rect does PrintableGeometry
// ...
endimpl

// Type intersections can only be used with behaviors.
// If two behaviors have conflicting symbols then the name of the bahavior must be used.

typedef Drawable behavior {
    draw()
}

typedef Text behavior {
    draw()
}

typedef UiText struct {}

impl UiText does Drawable, Text

fn Drawable::draw() {
    // do stuff
}

fn Text::draw() {
    // do stuff
}

endimpl

let t: UiText
t.Drawable::draw()

// Behaviors can have overridable function implementations

#[requireConstImpl]
typedef Allocator behavior {
    alloc(): rawptr
    free()
    
    md printStats() {
        fmt::println("Allocated {} bytes.", allocated)
    }
    
    allocated: int
}

// These overridable function implementations can't be called directly from the behavior but if a
// struct impl does the behavior it "inherits" that function.

typedef MyAllocator struct {}

constimpl MyAllocator does mem::Allocator

md alloc() { /- ... -/ }
md free() { /- ... -/ }

endimpl

allocator := MyAllocator{}
// Use the allocator.
allocator.printStats() // Prints number of bytes allocated.

// This allows for bahaviors to have optional functions that wont case a crash if they are called.
// These overridable function implementations can access any variables defined in the behavior but
// not variables in the struct that implements the behavior.

typedef MyAllocator struct {
    freed: int
}

constimpl MyAllocator does mem::Allocator

md alloc() { /- ... -/ }
md free() { /- ... -/ }

md printStats() {
    fmt::println("Allocated {} bytes, freed {} bytes.", allocated, freed)
}

endimpl

allocator := MyAllocator{}
// Use the allocator.
allocator.printStats() // Prints number of bytes allocated and freed.

// [ENUMS] ----------------------------------------------------------------------------------------

typedef Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL,
    TK_FUNCTION,
    TK_VAR,
}

// The above example is just like enums in c/c++. So TK_STRING = 0, TK_NUMBER = 1 ...

typedef Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL = 5,
    TK_FUNCTION,
    TK_VAR,
}

// Unless otherwise specified enumerators take the value of the enumerator before them + 1.
// TK_STRING = 0, TK_NUMBER = 1, TK_BOOL = 5, TK_FUNCTION = 6 ...

// The values in an enum must be unique.

typedef Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL = 5,
    TK_FUNCTION,
    TK_VAR = 6, // Invalid
}

// More advanced patterns can be used as well for the increments.
typedef EvensForSomeReason enum {
    unused = #jot * 2,
    First,  // 2
    Second, // 4
    Third,  // 6
}

typedef EvensForSomeReason enum {
    First = (#jot + 1) * 2,  // 2
    Second, // 4
    Third,  // 8
}

typedef Permission enum {
    Read = 1 << #jot, // 00000001
    Write,            // 00000010
    Delete,           // 00000100
}

typedef MemSize enum {
    unused = 1 << (#jot * 10),
    KB, // dec: 1024       bin: 00000000000000000000010000000000
    MB, // dec: 1048576    bin: 00000000000100000000000000000000
    GB, // dec: 1073741824 bin: 01000000000000000000000000000000
}

// 'jot' works much like 'iota' in go (the etymology nerds out there should love this).

// Enums can be types other than int. When this is the case all enumerators must be specified.

typedef Numbers enum: f64 {
    PI = 3.14159,
    E = 2.71828,
}

typedef Animals enum: string {
    Aardvark = "Aardvark",
    Cat = "Cat",
    Dog = "Dog",
}

// To get the name of a enumeration use the name_of operator.

num := Numbers.PI
name := name_of(num, Numbers)
fmt::println("num is {}", name) // Prints 'num is PI'

// If the value can't be found it will return an empty string.
num = 3.4
name = name_of(num, Numbers) // 'name' is an empty string.

// using can be used on enums.

typedef Numbers enum: f64 {
    PI = 3.14159,
    E = 2.71828,
}

// ...

using Numbers // Bring Numbers enumerations into the current scope.

num := PI // Valid
e := Numbers.E // Unlike with namespaces the name can still be used with using.

typedef Direction enum {
    North,
    South,
    East,
    West,
}

let dir: Direction = Direction.North

when (dir) {
    Direction.North: fmt::println("north")
    Direction.South: fmt::println("south")
    else: fmt::println("other") // Because we are using when on an enum else must be used to cover
    // the other cases.
}

// The complete attribute can be used to force all of the options to be considered in the when.
// else: can't be used with complete. complete can only be used with enums, otherwise it is a
// compiler error.

#[complete]
when (dir) {
    Direction.North: fmt::println("north")
    Direction.South: fmt::println("south")
    Direction.East: fmt::println("east")
    Direction.West: fmt::println("west")
}

// Functions can be implemented on enums as well.

typedef Color enum {
    Yellow,
    Red,
    Green,
    BLue,
}

impl Color

md greenPart[c: Color](): bool {
    when (c) {
        Color.Yellow,
        Color.Blue: return true
        else: return false
    }
}

md isGreen[self: Self](): bool {
    return self == Color.Green
}

endimpl

c := Color.Green
assert(c.isGreen()) // True

// [OPERATOR OVERLOADING] -------------------------------------------------------------------------

// Nifty will not have operator overloading. Leaving this section in anyways.

// Still haven't decided if nifty will have operator overloading. But if it does this is how it 
// will work. (Or it will only allow overloading related to [])

// Operator overloading is done in struct implementations via attributes.

typedef Point struct { x, y: f64 }

impl Point

#[overloads("+")]
md addPoints(other: Point): Point {
    return Point{x + other.x, y + other.y}
}

#[overloads("+")]
md addf64(scalar: f64): Point {
    return Point{x + scalar, y + scalar}
}

endimpl

// The following operators are overloadable:
// +, -, *, /, <<, >>, !, [], []=, [:], +=, -=, *=, /=, ==, !=, >, <, >=, <=, =, ++, --, in
// Unary +, -, and ++, -- are special cases.

#[overloads("+unary")] // +point
#[overloads("-unary")] // -point

#[overloads("++postfix")] // point++
#[overloads("++prefix")] // ++point

#[overloads("--postfix")] // point--
#[overloads("--prefix")] // --point

// What if you wanted to do
5.f + point // Invalid

// Because operator overloads are implemented on structs the struct object must be on the left.
point + 5.f // Valid

// Operator overloads work with bahaviors too.

typedef Addable behavior {
    #[overloads("+")]
    add(other: Self): Self // Use Self to indicate that the function will return the type of the
                              // struct impl that does this behavior.
    #[overloads("-")]
    sub(other: Self): Self
}

typedef Vec2 struct { x, y: f32 }

impl Vec2 does Addable

// Self can be used as the type.
#[overloads("+")]
md add(other: Self): Self {
    return Vec2{x + other.x, y + other.y}
}

// Or the name of the struct can be used as the type.
#[overloads("-")]
md sub(other: Vec2): Vec2 {
    return Vec2{x - other.x, y - other.y}
}

endimpl

// [UNION TYPES] ----------------------------------------------------------------------------------
// tagged unions

// Nifty has union types.

typedef Value as bool | s32 | f128 | string

// When using union types like this the default value is the default for the first type in the
// union.

let value: Value
assert(type_from(value) == bool) // True
assert(value == false) // True

let value: Value = undefined // Valid
assert(type_from(value) == bool) // True

assert(size_of(Value) == 16) // True

v: Value = 12
assert(type_of(v) == "s32") // True
assert(type_from(v) == s32) // True

when (type_from(v)) {
    bool: v = !v
    s32: v = 42
    f128: v = 123.456
    string: v = "yeet"
}

// Note that when using when with type_from -> and else: can't be used. All types in the union
// type must be cases in the when. Only the types in the union type can be used. It is better to
// use type_from instead of type_of with when as type_of returns a string an the compiler won't
// know if all the types and only the correct types are being used.

v = "yote" // v is type string now.
assert(type_of(v) == "string") // True
assert(type_from(v) == string) // True

// Union types have a hidden tag that keeps track of what that last type the union variable was set
// to. This is used internally for when, and type checking.

let aFloat: f128
aFloat = v // Error (could potentially be caught a compiletime).

if (type_from(v) == f128) {
    aFloat = v
}

aFloat = v else {} // The same as the above if statement.

aFloat = v else {
    fmt::println("value is not f128")
}

aFloat = v else {
    fmt::println("value is not f128, setting to 0")
    <- 0
}

aFloat = type_from(v) == f128 ? v : 0 // Another psossible way to handle it.

// Union types can not have arrays as a type in the union. (?)

// [GENERICS] -------------------------------------------------------------------------------------

fn add<typename T>(a, b: T): T {
    return a + b
}

typedef Point<typename T> struct {
    x: T
    y: T
}

// What if you wanted to store more than just int in the Collection struct above?
// Well then you would need to use generics.

typedef Collection<typename T> struct {
    list: []T
    _average: float // Private variable
}

impl Collection<typename T>

md init(size := 0) {
    list = []T{size: size}
}

md add(num: T) {
    append(list, num)
    _calculateAverage()
}

md average(): float {
    return _average
}

// Private function
md _calculateAverage() {
    total := 0
    for (val num in list) {
        total += num
	}

	average = cast(total, f32) / cast(len(list), f32)
}

endimpl

collection := new Collection<f32>{}
collection->add(12.f)

// You can also restrict methods to a certain type.

impl Collection<int>

md sum(): int {
    total := 0
    for (val num in list) {
        total += num
	}
}

endimpl

// The sum function is only available for Collection<int>.

collectionInt := new Collection<int>{}
collectionF32 := new Collection<f32>{}

// do stuff

sumInt := collectionInt->sum() // Valid
sumF32 := collectionF32->sum() // Comile error

// Generics are figured out at compile time so there is no runtime cost assosiated with them.

// You can specify what types are allowed to be used

typedef Vec3<T: int | float | double> struct {
    x: T
    y: T
    z: T
}

fn add<typename T: int | float | double>(a, b: Vec3<T>) { /- ... -/ }
fn sub<typename T: int | float | double>(a, b: Vec3<T>) { /- ... -/ }

// To make using multiple types like this easier you can use union types.

typedef IFD as int | float | double

// The above struct and functions could be re-writen like:

typedef IFD as int | float | double
typedef Vec3<typename T: IFD> struct { x, y, z: T }

fn add<T: IFD>(a, b: Vec3<T>) { /- ... -/ }
fn sub<T: IFD>(a, b: Vec3<T>) { /- ... -/ }

// If you want to make the above struct work so that any type of number can be used, but only numbers
// you can use the #number built-in macro.
typedef Vec3<T: #number> struct { /- ... -/ }

// Or if you only want to allow only all floating types only you can use the #decimal built-in macro.
typedef Vec3<T: #decimal> struct { /- ... -/ }

// Or if you only want to allow only all integer types only you can use the #integer built-in macro.
typedef Vec3<T: #integer> struct { /- ... -/ }

// I thought about having a number, decimal, and integer keywords but I don't think this would come up
// enough to merit three dedicated keywords.

// These conveniences (#number, #decimal, and #integer) only work with generics.
let num: #number = 12 // Invalid

// The union types work for impl or functions as well

impl Vec3<T: int | float | double>
impl Vec3<T: IFD>
impl Vec3<T: #number>

fn add<T: int | float | double>(a, b: T) { /- ... -/ }
fn add<T: IFD>(a, b: T) { /- ... -/ }
fn add<T: #decimal>(a, b: T) { /- ... -/ }

// Type 'void' can not be used as a type for generics.
typedef Thing<typename T> struct { /- ... -/ }
let thing: Thing<void> // Invalid
impl Thing<void> // Invalid

// Generics can use type intersections with behaviors. See the behaviors section for info.

// [POINTERS] -------------------------------------------------------------------------------------

// Pointers in nifty use the Pascal syntax.
// For types '^' is on the left and indicates it is a pointer type.
// For dereferencing '^' is on the right of the variable. 
// Like c/c++ '&' is the addressof operator.

let p: ^int // Pointers are null by default so p is null.
x := 12
p = &x // p now points to x
y := p^ // y is 12
p^ = 42 // x is 42


// Pointers to compiletime/runtime constants are constant as well.
const z = 12
ptr := &z
ptr^ = 42 // Invalid

val z = getInt()
ptr := &z
ptr^ = 42 // Invalid

// Nifty does not have pointer arithmetic.
let p: ^int = someFunc()
p++ // Invalid, this is supported via multi-value pointers.

// If the compiler knows that a value is null when it is being dereferenced is will not compile.
let p: ^f64
p^ = 12 // Invalid

let p: ^f64
// ...
p^ = 42 // Causes a panic if p is still null.

// If a function takes a pointer type then ^ is used on the left of the variable
// to visually indicate that.

fn someFunc(x: ^int) {
    // Do something
}

x := 12
y: ^int = &x

someFunc(^y) // Valid
someFunc(y) // Invalid
// This is not dereferencing y or doing anything other than passing y.
// This is just so the programmer can quickly see this function is taking
// a pointer and that y could potentially be modified by the function.
// TODO: Is this more annoying than it's worth?
// TODO: Maybe this can be optional and forced by a compiler flag?

// Pointers passed to functions can't be null by default.
fn takesPtr(ptr: ^int) {
    x := ptr^ // No need to check if ptr is null.
}

// assert_db will automatically get inserted into the function to make sure the pointer is not null.

fn takesPtr(ptr: ^int) {
    assert_db(ptr != null)
    x := ptr^
}

ptr := new int{12} // ptr^ is 12
// ...
takesPtr(^ptr) // Invalid, ptr could be null

if (ptr != null) {
    takesPtr(^ptr) // Valid
}

// To indicate that a function can take null pointers:
fn takesPtr(ptr?: ^int) {
    //
}

let ptr: ^int
takesPtr(^ptr) // Valid


// Optional pointers can be used for increased safety. Optional pointers must be unwrapped to be
// dereferenced. This avoids accidentally trying to use a null pointer or an already freed pointer.
let ptr: ^int? = null // Valid
let ptr: ^int? // ptr has no value, is null
x := 12
ptr = &x
let y: int

// To unwrap an optional pointer simply use it in an if statement.
if (ptr != null) {
    // ptr is now ^int, this is the only place nifty supports variable shadowing.
    assert(ptr^ == 12) // True
}

// Another way to unwrap the pointer is with the '?' operator.
assert(ptr?^ == 12) // True
ptr = null
assert(ptr?^ == 12) // False
// Would the above be
assert(null == 12) // ???


// ptr is type Optional<^int>

// To return an optional pointer '?' is used as well.
fn returnsOptionalPointer(): ^int?, bool { /- ... -/ }

// To indicate an optional pointer in a callback definition:
fn callsCallback(callback: fn(^int?): int)
// Or the name of the argument can be used.
fn callsCallback(callback: fn(arg: ^int?): int)

// Nifty has null coalescing.

x := 12
p: ^int = &x

y := p^ ?? 12
// The above line is the same as
let y: int
if (p != null) {
    y = p^
} else {
    y = 12
}

p ??= &x
// The above line is the same as
if (p == null) {
    p = &x
}

let ptrptr: ^^int = undefined // Invalid. 

// For multiple indirection/pointer arithmetic multi-value pointers are used.
let values = [1, 2, 3, 4, 5]
let valuesPtr: [^]Value = &valuesArr

assert(valuesPtr[0] == 1) // True
assert((valuesPtr + 3)[0] == 4) // True
valuesPtr++
assert(valuesPtr[0] == 2) // True

// Bounds checking applies to multi-value pointers as well. #noBoundsCheck can be used too.
valuesPtr += 10 // Invalid
valuesPtr[10] // Invalid

valuesPtr^ = 10 // Invalid
valuesPtr[0] = 10 // Valid

// [FUNCTION POINTERS] ----------------------------------------------------------------------------

fn addFn(a, b: int): int {
    return a + b
}

fn otherFunc() {
    add := addFn // Type is ^fn(int, int): int
    add(2, 2)
}

typedef AddFn as fn(int, int): int

fn add(a, b: int): int { /- ... -/ }
typedef AddFn as type_from(add) // Also works

// [MEMORY] ---------------------------------------------------------------------------------------

// Nifty is a manual memory management based language. Meaning that programmers must manage their
// own memory. Similar to c/c++. 

// Allocate memory for a Person type and point person to that memory and wrap it in an optional.
person? := new Person{}
if (person != null) {
    person->doAThing()
    delete person
}

assert(person == null) // True

// Pointers/optionals are automatically set to null after being deleted.

person2 := new Person()
person2->doAThing()
delete person2
assert(person2 == null) // True

// To prevent this behavior use undefined after the delete statement.
delete person2 undefined

// To create a custom allocator you must use constimpl and use the mem::Allocator behavior.

namespace custom_alloc

use mem

typedef CustomAlloc struct {} // The struct doesn't (technically) need any fields.

constimpl CustomAlloc does mem::Allocator

md alloc()<T> { /- ... -/ }
md free()<T>  { /- ... -/ }

endimpl

// ...

using "custom_alloc"

// Custom allocators can be used with the 'new' keyword.

ptr := new:CustomAlloc int

// Memory mest bee freed with the allocator it was allocated with.

delete ptr // Invalid
delete:CustomAlloc ptr // Valid

// or

customAlloc := CustomAlloc{}
ptr := customAlloc.alloc(int)

// To free all memory from an allocator mem::deleteAll can be used.
// To reallocate use mem::realloc.
// The specifics of these will be worked out later.

// [OPTIONAL] -------------------------------------------------------------------------------------

// Nifty has an optional type that can be used. Optional, is used by default.
// The idea is to have a way to have a variable with no value without crashing or panicking in any
// situation. Optional can only cause a panic if the programmer explicitly wants to panic.

fn someFunc(): Optional<string> {
    // ...
    if (someCondition) {
        return "a string" // Return does have a value.
    }
    
    return null // Return doen't have a value.
}

val opt = someFunc()
str := opt.valueElse("yeet") // str will be yeet if opt has no value, otherwise it is the contained value.

// Or
str := someFunc().valueElse("yeet")

// Another way to handle optionals is via else.
str := someFunc() else { "yeet" }

// There can be more than one statement in the block. If that is the case then <- must be used to
// "return" the value. If return is used it will return from the containing function.
// I decided on <- because it is clearer than using nothing and <- isn't used elsewhere and I don't
// want to add more keywords if I can avoid it. Open to suggestions on this.
str := someFunc() else {
    fmt::println("someFunc() was empty, defaulting to yeet.")
    <- "yeet"
}
// str is set to "yeet" on empty

str1, str2 := multipleOpts() else { "a", "b" } // Can't check which optional was empty. Not reccomended.

// Instead of writing out Optional a question mark can be used instead.
fn someFunc(): string? { /- ... -/ } // Same as fn someFunc(): Optional<string>

// Optionals can be in function arguments too.
fn anotherFunc(arg1: string?, arg2: string, arg3: string?): int
// Because optionals still have to be passed you can have a non-optional after an optional.

// Default values can be used as well.
fn anotherFunc(arg1: string?, arg2: string, arg3: string? = null): int

// Optionals can be used with pointers.
let opt: Optional<^int> // Default for Optional is null.
let opt: ^int? // Same as the above line
// This is detailed more in the [POINTERS] section.

opt.set(p) // Value is now p.

opt? := SomeStruct{id: "12"}
// Is the same as
let opt: SomeStruct? = SomeStruct{id: "12"}

let x: int? // x is null
let y: int

if (x != null) {
    y = x
}

y = x else { 12 }

// Optionals can't be of type 'void'.
fn returnsNothing(): void? // Invalid

// Included functions.
md valueElse(other: T): T // If the optional is null then other is returned. The other value can't be nullable.
md valueElseFn(other fn(): T ): T // If the optional is null then other is returned.
md valueElseDefault(): T // If the optional is null then the default value for the type is returned.
md valueElsePanic(msg: string): T // Panics with the given message if the optional is null, otherwise returns the value.

md hasValue(): bool // Returns true if it has a value.
md isNull(): bool  // Returns true if it is null.
md clear() // Set to null.
md set(value: T) // Set the value of the optional.

md value(): T // For compiler use only.

if opt [v] {
    assert(v == 12)
}

// With parens

if (opt) [v] {
    //
}

// Access by reference
if opt [^v] {
    v^ = 1
}

if opt [v] {
    assert(v == 1)
}

// [RESULT] ---------------------------------------------------------------------------------------

// Results are a lot like optionals, except that results either have a value or an error.

fn someFunc(): Result<string> {
    if (someCondition) {
        return "a string"
    }
    
    return Error("this is an error")
}

// Like optionals, results have a syntax shortcut.

fn someFunc(): string! { /- ... -/ } // Same as above.

result := someFunc()
str := result.valueElsePanic(result.err())

str := someFunc() else {
    panic(error.msg()) // error is automatically defined in the else block
}

// If error is already defined or you just want to use a different name you can. Or you can
// explicitly define error. Noe that 'e' is only defined in that block.
str := someFunc() else (e: Error) {
    panic(e)
}

str := someFunc() else { "yeet" } // Ignore the error and set to "yeet".

str := someFunc() else {
    fmt::println(error)
    <- "error :("
}

// This pattern:
str := someFunc() else { return error }
// Is the same as: 
str := try someFunc()
// This is not try as in try catch. try evaluates the Result and if it has an error it returns the
// error. Nifty does not have exceptions or a catch keyword.

// Included functions.
md valueElse(other: T): T // If the result has an rror then other is returned. The other value can't be nullable.
md valueElseFn(other fn(): T ): T // If the result has an error then the result of the provided function is returned.
md valueElseDefault(): T // If the result has an error then the default value for the type is returned.
md valueElsePanic(msg: string): T // Panics with the given message if the result has an error, otherwise returns the value.

md hasValue(): bool // Returns true if it has a value.
md hasError(): bool  // Returns true if it has an error.
md clear() // Clears the value/error.
md setValue(value: T) // Set the value of the optional.
md setError(err: does Errorable) // Set the value of the optional.

if result [value] {
    assert(value  == 12)
} else [err] {
    panic(err)
}

// With parens

if (result) [value] {
    assert(value  == 12)
} else [err] {
    panic(err)
}

// [ERROR HANDLING] -------------------------------------------------------------------------------

// panic() will cause the program to exit when it is called.
panic("Some error!")
// The messagfe gets printed just before the program exits.

// panic is an oveloaded function that is always available.
fn panic overloads { panicMsg, panicErrorable }

// assert will panic with an optional message if the given statement is false.
assert(true == false) // Will panic.
assert(true == false, "True is not false!") // Will panic with the given message.
// Like panic assert is always available.

// There are multiple ways to handle errors in nifty.

// One way is the comma ok idiom.
fn someFunc(): int, bool { /- ... -/ }
idx, ok := someFunc()
if (!ok) {
    // Some error
}

// Or
if (idx, ok := someFunc(); !ok) {
    // Some error
}

// Errors can also be returned.
fn someFunc(): int, Error { /- ... -/ }
idx, err := someFunc()
// Returning an Error will always be a valid object, so check if an error actually occured.
if (err.occured()) {
    panic(err)
}

// Or similarly a pointer to an error can be returned.
fn someFunc(): int, ^Error { /- ... -/ }
idx, err := someFunc()
if (err != null) {
    panic(^err)
}

// Rather than returning T, Error it is preferable to return Result<T>.
fn someFunc(): int! { /- ... -/ }
idx := someFunc() else { panic(error) }

// [TESTS] ----------------------------------------------------------------------------------------

// Nifty has built-in testing. Test files are not compiled into the executable in neither debug nor
// release modes.

using testing // For functions like expect, expectEq, etc

fn add(x, y: int): int {
    return x + y
}

test "add 2, 2" {
    try expectEq(add(2, 2), 4)
}

test "basic while test" {
    x := 0
    while (x <= 100) {
        ++x
    }
    
    try expectEq(x, 100)
}

// To skip a test use the skip keyword.
test skip "this will be skipped" {
    try expect(true)
}

skip test "this will be skipped" {
    try expect(true)
}

// Tets don't have to have a name

test {
    try expectEq(add(2, 2), 4)
}

// Unnamed tests can be skipped

skip test {
    try expect(false)
}

// or

test skip {
    try expect(false)
}

// skip can't be used on it's own

skip "this will be skipped" { // Invalid
    try expect(false)
}

skip { // Invalid
    try expect(false)
}

fn someFunc(data: SomeStruct): !bool {
    // ...
}

test "test error" {
    badData ::= SomeStruct{}
    res ::= someFunc(badData)
    try expectError(res)
    try expectErrorToBe(res, Error("bad data"))
}

#[timeout(100)] // Set the timeout for this specific test to 100 seconds.
test "long test" {
    // Long test here
}

// Have a timeout option for tests.
// A timeout option for individual tests and the test command as a whole.

// expect(), expectEq() return bool!.

// Tests can be written in to any nify file. They can also be in their own files in the format of *.test.nifty

// To run the tests
// nifty test
// Will run all the test files.

// To run a specific test file
// nifty test while.test.nifty

// To run a specific test in a specific test file
// nifty test while.test.nifty "basic while test"

// To run tests starting with a specific string
// nifty test filter "math"
// Unnamed tests are still ran.

// [IMPLICIT CONTEXTS] ----------------------------------------------------------------------------

// Every function in nufty has an implicit context that gets passed to it, unluess #[noContext] is
// used. The context can be used to modifty how existing libraries allocate memory or do logging.

fn someFunc() {
    context->userIndex = 123
    
    newContext := context
    newContext->allocator = someCustomAllocator
    newContext->userIndex = 456
    
    // Push the context, pops at the end of the scope.
    #push(newContext) {
        otherFunc()
    }
    
    assert(context->userIndex == 123) // True
}

fn otherFunc() {
    ptr := new int{12} // When called from someFunc() this uses someCustomAllocator.
    println(x^)
    delete x // When called from someFunc() this uses someCustomAllocator.
    
    assert(context->userIndex == 456) // True when called from someFunc().
}

#[noContext]
fn noContext() {
    fmt::println(context->userIndex) // Invalid, context is not defined anywhere.
}

// By default the context is implicitly passed in as 'context'. This can be changed with a receiver
// argument.

fn someFunc[ctx: ^NiftyContext](x: int) {
    ctx->userIndex = x
}

// Contexts could also be used for thread safe memory management as each thread would have a
// different context.

// The context struct will look something like this:

typedef NiftyContext struct {
    allocator: does Allocator
    allocatorTmp: does Allocator
    assertionFailure: fn(prefix, msg: string, loc: SourceLocation)
    logger: does Logger
    
    userData: rawptr
    userIndex: int
    
    internal: rawptr #[compilerOnly]
}

// [MACROS] ---------------------------------------------------------------------------------------

// Nifty has an intentionally very limited subset of macros mainly meant for compiletime decisions.

#define SOME_CONST_MACRO
// SOME_CONST_MACRO is defined but doesn't have a value.

#buildIf(SOME_CONST_MACRO) {
    // Code to comile if SOME_CONST_MACRO is defined (not a scope)
} #else {
    // Code to compile if SOME_CONST_MACRO is not defined (not a scope)
}

#undef SOME_CONST_MACRO
// SOME_CONST_MACRO is no longer defined.

// Values can not be set with #define. This just defines the macro internally in the compiler.
// To set values in a macro use #set. The values being set must be resolvable at compile time.
// It does not work like c/c++ where the macro is replaced by the expanded contents of the macro.
// They MUST resolve to a constant value. Macros are type checked as well, unlike in c/c++.

#set OTHER_CONST_MACRO 12

// Macro values can be used by variables as well.
someVar := #OTHER_CONST_MACRO
// When macro values are used outside of other macros they must start with a '#'.
someVar := OTHER_CONST_MACRO // Invalid

#buildIfTrue(OTHER_CONST_MACRO == 12) {
    // ...
}

#unset OTHER_CONST_MACRO
// OTHER_CONST_MACRO is no longer set to anything or defined.

// I've decided to not allow user defined macro functions for simplicity. Macros can easily be
// abused and make code VERY hard to read. This could change in the future as macros can be very
// powerful if done correctly.

// Macros can't be set to other macros.
#set THIRD_CONST_MACRO OTHER_CONST_MACRO // Invalid

// Built in macros
// Some of the built in macros are more like keywords than macros. This is because they are useful
// and help out the compiler but are not expected to be used frequently enough to merit their own
// keyword. For instance #number

#file           // replaced with the filename
// #fileRaw        // usually the same as #file but if in a macro will show the filename the macro is in, not where it is used
#path           // replaced with the full file path
// #pathRaw        // usually the same as #path but if in a macro will show the path the macro is in, not where it is used
#line           // replaced with the line the macro is on
// #lineRaw        // usually the same as #line but if in a macro will show the line in the macro, not where it is used
#location()     // replaced with the location of the given function/variable/struct/other. If no argument is given then
                // the current location is used. The location is a struct with the filename, path, and line.
#callerLocation // replaced with a struct containing the calling function's location
#function       // replaced with the function name the macro is in
#namespace      // replaced with the name of the current namespace
#os             // replaced with the OS that the compiler is running on currently
#buildIf()      // will build the file/block only if the argument is defined
#buildIfAny()   // will build the file/block only if one or more of the arguments is defined
#buildIfNot()   // will build the file/block only if none of the arguments are defined
#buildIfAll()   // will build the file/block only if all of the arguments are defined
#buildIfTrue()  // will build the file/block onlyif all of the arguments evaluate to true
#buildIfFalse() // will build the file/block onlyif all of the arguments evaluate to false
#time           // replaced with the current time HH:MM:SS
#date           // replaced with the current date yyyy-mm-dd

// The raw macros are commented out because they are currently unnecessary. But if I decide to
// allow user defined function macros they will be useful to have so they stay on the list for now.

#niftyVersion      // replaced with the version of the nifty compiler
#niftyVersionMajor //
#niftyVersionMinor //
#opt               // replaced with the current optimization level

#counter           // replaced by an incremented value starting at 0, it is incremented everytime it is encountered and never reset
#jot               // replaced by an incremented value starting at 0, it is incremented everytime it is encountered and reset every block

#number            // used by generics, see the section on generics for details
#decimal           // used by generics, see the section on generics for details
#integer           // used by generics, see the section on generics for details

#noBoundsCheck     // does not check bounds in the given block or statement
#checkBounds       // will always check bounds in the given block or statement

#strictIEEE        // ignores IEEE breaking optimizations for the code block. If an algorith relies
                   // on IEEE correctness then this should be used while the optimizations can be 
                   // used in the rest of the code. Some optimizations may still happen anyway as
                   // they can be a thread level optimization (e.g. flush to zero). If that is the
                   // case for you then glhf.

#push(context: ^NiftyContext)

fn someFunc() {
    fmt::println("This code is in {}::{}:{}() L{}", #namespace, #file, #function, #line)
    // This code is in default::main:someFunc() L3
}

// The following don't expand to anything, they are either defined or not.
#OS_MAC
#OS_WINDOWS
#OS_LINUX
#OS_FREE_BSD
#OS_OPEN_BSD
#OS_NONE

#ARCH_ARM64
#ARCH_AMD64
#ARCH_X86_64
#ARCH_X86

// More to be added as support is expanded.

#embedBytes(path: string, limit: u64 = 0, compress: string = "")  // Loads a file up to limit bytes and returns its contents as a []u8
#embedString(path: string, limit: u64 = 0, compress: string = "") // Loads a file up to limit bytes and returns its contents as a string
// If compress is set then it will compress the data using the given method. The only option is zlib, more will be added later.
// If limit is 0 for either then there is no limit (until you run out of RAM that is).

// #embedBytes and #embedString only embed in the binary on release builds. This is done to speed up
// compile times during development. If not a release build it will be loaded at runtime.

const RAND = #embedBytes("/dev/urandom") // Will crash the compiler, possibly your computer.
const ARR = #embedBytes("/dev/urandom", 128) // Type is [N]u8 where N is the number of elements determined at compile time.

let str: string = #embedString("hello.txt");
println(str) // hello.txt contents

#env(var: string): string // Used to get environment variables at compiletime. Returns empty string if not found.
compileTimeEnv := #env("SOME_VAR")

#buildIf(#env("IS_CI") == "true") { /- ... -/ }

#error(msg: string) // Causes the compiler to error with the given message.
#warn(msg: string) // Causes the compiler to emit a warning with the given message.
#info(msg: string) // Prints the message to stdout.

#TODO(msg: string) // Prints the message to stdout prefixed with highlighted "TODO:".

#assert(condition: bool, msg: string = "") // Compiletime assert. Will cause a compiler error with
                                           // with the optional message on failure.

// [SIGNALS AND SLOTS] ----------------------------------------------------------------------------

// Probably not.

// Instead of callbacks signals and slots can be used in Nifty. When a signal is emitted the
// corresponding slot or slots are called. This system is type safe so the signature of the signal
// and the slot must match. When a signal is emitted the emitter neither knows nor cares which slots
// receive the signal. If a signal is emitted all the corresponding slot will reveive it.
// Signals and slots can either be standalone functions or methods implemented on a struct. The
// two different types can be mixed. For instance a function can emit a signal that is recieved by
// a slot method. Signals do not have implementations and thus must use undefined for the body.
// Slots on the other hand do have implementations so the fn or md keyword is required. This means
// that slots can be called like any normal function or method. One signal can be connected to many
// slots and vice versa. Signals can even be connected to other signals. When this is the case when
// the signal is emitted the signal connected to it is also immediatly emitted. If multiple signals
// or slots are connected togther they are executed in the order they were connected.
// Signals and slots can be slower than just using callbacks because there are runtime checks that
// happen in the background to make sure the calls to any objects are safe. However in almost all
// cases the convenience and flexability is worth the overhead.

// Signals must never return a type, they must be void and they must be undefined.
#[signal]
fn valueChanged(newVal: int) undefined

// Slots can return a type as they are otherwise normal functions. However in many cases the return
// value will be discarded. Because of this the #[useReturn] attribute can't be used with slots.
// A warning will be emitted if a slot returns something.
#[slot]
fn setValue(newVal: int) {
    someVal = newVal
}

#connect_fn(valueChanged, setValue)

// Optionally the types can be specified.
#connect_fn(valueChanged(int), setValue(int))

// ...

emit valueChanged(changedVal)

#connect_fn(emitterFn, receiverFn)
#connect_md(^emitter, Emitter::method, ^receiver, Receiver::method)
#connect_fn_md(emitterFn, ^receiver, Receiver::method)
#connect_md_fn(^emitter, Emitter::method, receiverFn)

emit emitterFn()

// [ORM] ------------------------------------------------------------------------------------------

// The ORM is Called Norm (Nifty Object Relational Mapping).
// One syntax for all SQL dialects. Queries are made within nifty. This allows for compile time
// checks as well as automatic sanitization, and improved readability. This feature is a stretch
// goal and would likely be one of the last parts of the language to be worked on.

#[normTable("people")]
typedef Person struct {
    id:        int        #[norm("primaryKey, autoIncrement")]
    name:      string     #[norm("notNull")]
    userName:  string     #[norm("notNull, unique")]
    address:   string
    dob:       time::Date #[norm("notNull")] // yyyy-mm-dd
    createdAt: time::Time
    updatedAt: time::Time
}

use fmt
use sqlite

// Norm allows queries to be type checked.

db := sqlite::connect("the.db")  // Error handling skipped here for simplicity.

#sql(db) {
    create table Person
}

person := Person{ name: "Alice Bob", userName: "alice_bob42", dob: "1990-10-20" }

#sql(db) {
    insert person into Person
}

alice := #sql(db) {
    select from Person where name == "Alice Bob" limit 1
}

fmt::Println(alice.name)

#sql(db) {
    update Person set name = "Samantha Bobert" where id == alice.id
}


// [MISC] -----------------------------------------------------------------------------------------

b := false
assert(type_from(b) == bool) // true
assert(type_of(b) == "bool") // true

let c: type_from(b) // c is type bool
assert(type_from(c) == bool) // true
assert(type_of(c) == "bool") // true

a := typeid_of(bool)
x := 12
b := typeid_of(type_from(x))

type_of() // Returns string
type_from() // Returns type
typeid_of() // Returns typeid
typeinfo_of() // Returns TypeInfo struct (?)

num := 42.f
assert(size_of(num) == 4) // true

typedef Point struct {
    x: f32
    y: f32
}

assert(align_of(Point) == 4) // true

restrict // See https://en.wikipedia.org/wiki/Restrict

fn updatePointers(restrict ptrA: ^int, restrict ptrB: ^int, restrict value: ^int) {
    ptrA^ += value^
    ptrB^ += value^
}

fn updatePointers(restrict ptrA, ptrB, value: ^int) { /- ... -/ }
// It is important to note that if the function is formed like this 'restrict' only applies to ptrA.
fn updatePointers(restrict ptrA, restrict ptrB, restrict value: ^int) { /- ... -/ } // Better

// If you need to use existing c code you can use the 'extern' keyword.

namespace libc
use extern "libc.lib" as libc // Because c libraries don't have namespaces 'as' must be used to give
                              // the library a name. Can be the same as the namespace name.

// To tell nifty what is being used you must define everything with extern and the library name.

// Let nifty know what is in the libc namespace.
extern libc {
    typedef size_t as uint
    
    EOF ::= -1
    stderr: ^FILE
    
    fn fclose(file?: ^FILE): int undefined
    fn fflush(file?: ^FILE): int undefined
    
    // The underscore at the front of the function doesn't mean anything here. 
    // Everything in extern namespaces is public.
    #buildIf(OS_WINDOWS) { fn _aligned_malloc(size, alignment: size_t): rawptr undefined }
    #buildIfNot(OS_WINDOWS) { fn aligned_alloc(alignment, size: size_t): rawptr undefined }
    // extern functions do not have a context passed to them.
}

res := libc::fflush(^file)

// asm will be experimental at first.

#[asmReturn]
fn power2(num, power: int): int {
    #asm {
        mov eax, num   // First arg
        mov ecx, power // Second arg
        shl eax, cl    // eax = eax * (2 ** cl)
    }
    
    // Return value is stored in eax, so no return statement.
}

// Wrapping operators

// Integers are not allowed to overflow by default. But sometimes overflow is acceptable. In those
// cases wrapping operators can be used.
%+, %-, %*, %/, %+=, %-=, %*=, %/=, %++, %--

x : u8 = 255
x @+= 1
assert(x == 0)

// Saturating operators

// Integer overflow is undefined behavior so it is not allowed. Saturating operators will not cause
// integer overflow. Instead they will be clamped to the minimum/maximum of the type.
@+, @-, @*, @/, @<<, @+=, @-=, @*=, @/=, @<<=, @++, @--

x := math::MAX_INT
x @+= 1
assert(x == math::MAX_INT) // true

// #[unpredictable] is used to indicate that a branch condition is unpredictable by hardware
// mechanisms such as branch prediction logic

#[unpredictable]
if (unpredictableCondition) {
    // ...
}

#[unpredictable]
when (x) {
    // ...
}

#[unreachable]
// code

// Windows only. Use the console attribute to force the console to always be open for graphical
// programs. This attribute is only valid on the main function. On non-windows platforms this
// attribute does nothing.
#[console]
fn main() {
    // ...
}

// Same as above but only in debug mode.
#[debugConsole]
fn main() {
    // ...
}

// [BUILDING] [CONFIG] ----------------------------------------------------------------------------

// The build file is done with TOML. The default build file name is 'build.toml'.
// Each build file can have multiple targets.

// A common usecase for having multiple targets is having a debug build and a production build.

project = string

[<TargetName:string>]
outputName = string 
// Name of the output.
description = string
// Description of the target.
entryPoint = string 
// The file containing 'main()'.
noMain = bool 
// Set to true to remove the requirement for a 'main()' function. Defaults to false.
cmdOnly = bool
// Set to true if there is no code to compile for the target. Defaults to false.
commands = [[string], [string]]
// List of commands to be executed. Can only be used if cmdOnly is true.
noDeprecated = bool 
// Error if a function marked deprecated is used. Disabled by default.
noGoto = bool 
// Error if goto is used. Enabled by default.
debug = bool 
// Compile to debug mode. Disabled by default.
defines = [string] 
// defines = ["name=value", "name2=value2"]
errorOnWarn = bool 
// Treat warnings as errors. Disabled by default.
noWarn = bool 
// Disable warnings. Disabled by default.
optimization = string 
// Sets the optimization level. Options are none, fast, size, debug. 
// Defaults to "none". This is set to 'debug' if debug mode is enabled.
default = bool 
// Defaults to true in the first target, otherwise false. Can only be true for one target at a time.
boundsChecks = string 
// When to check bounds. Options are always, debug, never.
children = [string]
// List of child targets that will be run when this target is complete.
disallowNull = bool
// If eanbled pointers will not be allowed to be null. Defaults to false.
macroRecursionDepth = int
// The number of nexted macros that are allowed to exist. Defaults to 2.
executeBefore = [[string], [string]]
// Array of paths to scripts or commands to be executed before compiling begins.
executeAfter = [[string], [string]]
// Array of paths to scripts or commands to be executed after compiling finishes.
// executeBefore, and executeAfter can be set to only execute on a certain platform
executeBefore = [["windows"], ["some/path/script.bat"]] // Will only run on windows.
executeBefore = [["unix"], ["some/path/script.sh"]] // Will only run on unix-like systems (mac, linux, bsd).
executeBefore = [["mac"], ["macSpecificCmd -withArg"]] // Will only run on mac.
// The above 3 examples can all be in the same project simultaneously and will be executed in order.
// To run on all use 'all'.
executeAfter = [["all"], ["bla"]]
// Valid options are mac, windows, linux, unix, bsd, freeBsd, openBsd, all.
// Where unix is a superset of linux, mac, bsd.
// Where bsd is a superset of freeBsd, openBsd.
deprecatedAfterWarnWithin = int
// If deprecatedAfter is used on a function this will start emitting a warning x number of days before
// the date given to deprecatedAfter that the function will be deprecated soon. Disabled if <= 0. Defaults to 0.
noUnusedOnErrorReturn = bool
// Don't allow unused to be used on functions that return errors or results. Disabled by default.
fastMath = bool
// Like -ffast-math in GCC, False by default. Enabled with optimization="fast".
finiteMathOnly = bool
// Disabled by default. Enabled with optimization="fast", or fastMath=true
associativeMath = bool
// Disabled by default. Enabled with optimization="fast", or fastMath=true
unsafeMathOptimization = bool
// Disabled by default. Enabled with optimization="fast", or fastMath=true

// Options that are enabled by other options such as finiteMathOnly can overwrite those options.
optimization = "fast"
finiteMathOnly = false // All the other optiomizations from "fast" are still enabled.

// Where to look for namespaces.
includeDirectories = [string]

/-

nifty new // Interactive dialog to create a new nifty project

nifty build // Builds using the default build file in the current directory.
nifty build [fileName.extension] // Builds using the specified build file or source file.
nifty build [targetName] // Builds using the specified target with the default build file.
nifty build [buildFile]:[targetName] // Builds using the specified target with the specified build file.

nifty run // Takes the same arguments as 'nifty build' but builds and then runs the project.

nifty run prod // Builds and runs using 'build.toml' with target 'prod'.
nifty run server:debug // Builds and runs using 'server.toml' with target 'debug'

When not specifying a target the first target is used by default. Targets can optionally be marked
as the default. Only one target may be marked as default at a time.

nifty create [options] // Creates a new nifty project. Like nifty new but requires no user interaction.
nifty create name=tst

If no command is given then 'run' is used by default.

nifty [fileName.extension] // Same as nifty run [fileName.extension]
nifty [targetName] // Same as nifty run [targetName]
nifty [buildFile]:[targetName] // Same as nifty run [buildFile]:[targetName]
nifty // Will run the default target in the default build file.

If a target has the same name as a command then the command must be used as well.
For instance if you had a build target you would have to use
nifty run build
or
nifty build build

To list all of the targets and their descriptions for the default build file use
nifty list

To specify a build file to list use
nifty list [buildFile]

To delete compiled files for a nifty project use
nifty clean

To delete compiled files for a specific target use
nifty clean [targetName]

-/

/-

Nifty will also eventually have two standard tools. A nifty LSP (Language Server Protocol) called Dandy
and a code formatting tool called Neato. Neato will be configurable to run everytime a file in a watched
directory is updated.

-/

/-

Have a command to find overloaded operators.
nifty report overloadedOperators

-/

// [KEYWORDS] -------------------------------------------------------------------------------------

if
else
elif
while
until
for
return
when
break
continue
impl
constimpl
endimpl
in
defer
defer_err
try
restrict
goto
cast
recast
auto_cast
type_of
type_from
typeid_of
typeinfo_of
size_of
name_of
align_of
new
delete
null
unused
undefined
true
false
namespace
api
use
using
as
extern
behavior
does
struct
enum
bool b8 b16 b32 b64
char
string cstring
int uint
float double
s8 s16 s32 s64 s128
u8 u16 u32 u64 u128
f16 f32 f64
void
typeid
rawptr uintptr
let
val
const
fn
md
typedef
emit

// Keywords that can be used as variables/function names
test
skip

// Built in functions
assert() // In debug and release mode.
assert_db() // Only in debug mode.
panic()

// [TODO / IDEAS] ---------------------------------------------------------------------------------

/-

If there is a question mark after that means I'm not sure if I want to add that
to the language. Otherwise it is something I want in the language I just haven't
written it into the spec yet.

SOA data types
complex types (?)
quaternion types (?)
explicit little/big endian types (?)
matrix type (?)
map type (?)

coroutines/channels/processes (?)
compiletime code execution with #run (JIT)
insert code from a string or code at compiletime with #insert
#expand to turn functions into macros (?)
get access to AST at compiletime
user attributes (possibly explaned in nsl)
matrix data type (?)
complex number data type (?)
time traveling debugger (?)
built-in shell scripting mode (?)
translate c code to nifty (extra feature)
c backend (?)
compatibility with c ABI (for X system)
undefined behavior for unsigned integer overflow
build artifact caching
unreachable (?)
something like NORM for graphql (?)
anonymous structs (?)

build system done in nifty instead of a toml project file, build.nifty

pipe operator
foo(bar(baz(new_function(other_function()))))
becomes
other_function() |> new_function() |> baz() |> bar() |> foo()

Shoould x be marked as write only until it's written to (compiletime)?
let x: int = undefined
y := x // Error? Warning?

-/

// Include c code and use it. 

use extern "raylib.h" as raylib

fn main() {
    SCREEN_WIDTH  ::= 1024
    SCREEN_HEIGHT ::= 600
    
    raylib::InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "basic raylib window")
    defer raylib::CloseWindow()
    
    until raylib::WindowShouldClose() {
        raylib::BeginDrawing()
        defer raylib::EndDrawing()
        
        raylib::ClearBackground(raylib::RAYWHITE)
        raylib::DrawText("Hello, world!", 100, 100, 20, raylib::BLACK)
    }
}

// Symbol table, takes namespace name and symbol name as keys
// Have an imported table for symbold from other namespaces that have been brought into the current namespace/scope

fn printValues(fmt: string, values: ..__anytype) {
    // ...
}

fn printValue(value: __anytype) {
    // ...
}

fn print overloads { printValues, printValue }

fn printValuesLn(fmt: string, values: ..__anytype) {
    printValues(fmt, args)
    print("\n")
}

fn printValueLn(value: __anytype) {
    printValue(value)
    print("\n")
}

fn println overloads { printValuesLn, printValueLn }

// A tuple is an ordered, immutable collection of elements.
// Basically an anonymous struct.

values := .{1234, 12.f, true, "yeet"}
yeet := values.3
newValues := values ++ .{"bla"}
bla := newValues[4]

values.len() == 5 // true

// Destructuring can also be used to access the elements.
[a: int, b: f32, c: bool, d: string] := values
// or
[a, b, c, d] := values

tuple := {123, 456, "abc", "def", false}

fn returnTuple(): .{int, string, f32} {
    return .{123, "abc", 12.f}
}

fn takesTuple(tuple: .{int, string, bool}) {
    if tuple.0 == 12 {
        // do stuff
    }
}

typedef TwoInt as .{int, int}

fn getPosition(): TwoInt {
    x := someFuncX()
    y := someFuncY()
    return .{x, y}
}

[x, y] := getPosition()

// [NSL] ------------------------------------------------------------------------------------------

/-

math
    random
    noise
    big
    complex
    matrix
    vector

config
    toml
    json
    yaml
    env

network
    ftp
    udp
    http
    websocket
time
os
reflection

compress
    zlib

crypto
    bcrypt
    aes
    sha256
    sha512
    md5

encoding
    base32
    base64
    csv
    hex

fmt
io
hash
fs
    path

thread
window

collection
    map
    queue
    stack
    vector
    list (linked list)
    btree

db
    mysql
    
regex

Optionals

sdl
glfw
dear_imgui
lua
stb
    image

vulkan

-/
