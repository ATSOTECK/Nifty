// [TOP]
// [HELLO WORLD]
// [COMMENTS]
// [VARIABLES]
// [TYPES]
// [PACKAGES]
// [FUNCTIONS]
// [CONTROL FLOW]
// [DEFER]
// [RANGES]
// [ARRAYS]
// [SLICES]
// [ENUMS]
// [STRUCTS]
// [OOP]
// [GENERICS]
// [POINTERS]
// [FUNCTION POINTERS]
// [MACROS]
// [MISC]
// [BUILDING]

// Nifty is a new systems programming language in development.
// This file is an overview of the language and (basically) everything in here is
// subject to change. I am open to suggestion and if anything is unclear let me
// know. This file is much easier to read in vscode with the nifty extension.
// The extension is in the highlighting/vscode folder and you can copy and paste
// it into you vscode extensions folder to install it. You will have to restart
// vscode for it to go into effect.

/-

Naming conventions:

The following naming conventions are my personal preference and are what nifty uses.
These are not enforced by the compiler.

functions:          camelCase
types:              PascalCase
enum values:        PascalCase
variables:          camelCase
macros:             camelCase
macro constants     SCREAMING_SNAKE_CASE
constants:          SCREAMING_SNAKE_CASE
package names:      snake_case
keywords:           snake_case
built-in functions: snake_case
built-in types:     snake_case

The following naming conventions ARE enforced by the compiler.

Exports may not start or end with an underscore.
Privates must start with an underscore.
Locals must end with an underscore.

-/

// [HELLO WORLD]

package main

use "nsl.fmt"

fn main() {
    fmt::println(“Hello, world!”)
}

// Semicolons are optional.

// [COMMENTS]

// Single line comments use '//'.
// This is a comment.

/-
    Multiline comments use '/-' and '-/'
    Comments can be nested so the following is valid
-/

/-
    /-
        // bla
    -/
-/

/- Multiline comments can be on just one line too -/

/*
    C-style comments can be used as well and mixed with nifty comments.
*/

/-
    Like so
    /*
        and so
    -/
*/

// Why not just use /* */? I'm lazy, but you do you.

// [VARIABLES]

// Variables are declared with the 'let' keyword.
let x = 12

// The variable declaration operator can be used as well.
x := 12 // int
y := 12.f // f32
y := 12.0 // f64
y := 12.d // f64

// The types are inferred but can be specified.
let x: int = 12
x: int = 12

// If no value is specified the type must be specified
let x // Invalid
let x: int // Valid

// Immutable variables (runtime constants) are declared with the 'val' keyword.
val x = 12

// The constant declaration operator can be used as well.
x ::= 12

// The type is inferred for constants as well but it can also be specified.
val x: int = 12
x :: int = 12
val y: int // Invalid

// Variables are auto initialized in Nifty.
let x: int
y := x // Valid, both will be 0

// Variables can be explicitly uninitialized
let x: int = undefined
x := undefined // Invalid, no type given
x: int = undefined // Valid

// It is important to know that undefined is only used for declaring variables. 
// You can't check to see if a variable is undefined.
if (x == undefined) // Invalid
// Because of this undefined is NOT null
undefined == null // Invalid

// A variabled can't be later set to undefined.
x := 12
x = undefined // Invalid

buf : u32 = undefined
bufNum := buf // Invalid?

// Immutable variables can not be set to undefined.
val someVal: int = undefined // Invalid

// Nifty does not support variable shadowing.

fn someFunc(x: int) {
    x := 12 // Invalid
}

fn someFunc() {
    someVar := 12
    {
        someVar := 42 // Invalid
    }
}

// Variables can also be unused.
// Lets say you have a function getFromTable that returns true if the key is in the
// table, false otherwise, and takes a pointer to a Value that's where the value gets
// set if it is in the table. But you don't care about the value in the table  you
// just want to know if it is there and there is no other way provided by the library.
// This is a contrived example because nifty supports multiple returns.

let value: Value = undefined
inTable := getFromTable(someTable, someKey, &value)
// This will give an error that 'val' isn't being used.

let unused: Value = undefined
inTable := getFromTable(someTable, someKey, &unused)
// 'unused' is a special variable name that lets the compiler know the variable is
// unused. In the case 'getFromTable' will be able to set the variable from inside
// the function and then the unused variable will be immediatly freed and can be
// used again.

let unused: Value = undefined
inTable := getFromTable(someTable, someKey, &unused)

let unused: Value = undefined // Because 'unused' is a special variable name it can be redefined.
inTable2 := getFromTable(someOtherTable, someOtherKey, &unused)

// If it will be used with the same type it doesn't have to be redefined.
let unused: Value = undefined
inTable := getFromTable(someTable, someKey, &unused)
inTable2 := getFromTable(someOtherTable, someOtherKey, &unused) // Also valid

// unused can't be immutable.
val unused: Value // Invalid


// [CONSTANTS]

// Constants use the 'const' keyword and their value must be determined at compile time.
const x = 12
const y = someFunc() // Invalid
const z = #MACRO_CONST // Valid
const w = #constEvalFunc() // Valid

// The constant declaration operator can be used as well.

x ::= 12

// The compiler will differenciate between a runtime constant and a compile time
// constant so the same operator can be used.

// Constants can't be undefined or unused either.

// [TYPES]

// Basic Types:
char // same as s32
int // same as s32
uint // same as u32
float // same as f32
double // same as f64

bool b8 b16 b32 b64

u8 u16 u32 u64 u128
s8 s16 s32 s64 s128

f16 f32 f64

string

// Strings will be fully supported via the standard library, the string type is very basic.
// Strings (nsl.string) will be included by default since they are so common. (Maybe?)

// Custom types can be created as follows:

type Custom as int

// Casting uses the 'cast' operator.

x: s8 = 100
y := cast(x, s32) // cast(var, type)

// Types in nifty are not implicitly converted.

x := 12
y := 42
z: f64 = x / y // Invalid
z: f64 = cast(x, f64) / cast(y, f64) // Valid
z: f64 = cast(x / y, f64) // Valid, but probably not what you want.

x := 12
if (x) { /- ... -/ } // Invalid
if (x != 0) { /- ... -/ } // Valid

b := true
if (b) { /- ... -/ } // Valid
if (b == true) { /- ... -/ } // Valid, but like why?

p: ^int = null
if (p) { /- ... -/ } // Invalid
if (p != null) { /- ... -/ } // Valid

// [PACKAGES]

// All nifty programs are made of packages.

package main

use "nsl.fmt"
use "nsl.math"

fn main() {
    // Do something
}

// By default the name of the package is the last element of the package 
// path, which is also the name of the package in the file. This, however,
// can be changed with the 'as' keyword

use "nsl.fmt"
use "nsl.math" as M
use "nsl.math.random"

fn main() {
    fmt::println(M::PI) // math::PI is invalid
    fmt::println(random::number())
}

// Note the 'random' is a package inside the 'math' package and must be used
// separately from 'math'.

// All items inside a package can be added to the current scope with the 'using' keyword.

use "nsl.fmt"
using fmt // All items exported from the package fmt are now in this file's scope.

fn main() {
    println("Yo whaddup?")
}

// --- --- --- --- ---

use "nsl.fmt"

fn sayHi() {
    using fmt // All items from the package fmt are now in this function's scope.
    println("Hello")
}

fn main() {
    fmt::println("Yo whaddup?")   
}

// 'using' can also be used to import the package and bring it in to the file scope.
using "nsl.fmt"

fn main() {
    println("Hello world!")
}

// If two packages are brought into the same scope and they have any exported symbols
// with the same name then the package name must be provided to avoid ambiguity.

use "nsl.fmt"
use "foo"

using fmt
using foo // Lets say that package 'foo' also has a println function.

fn main() {
    println("Ya yeet") // Invalid
    foo::println("Yote") // Valid
}

// All items not starting or ending with an underscore are exported from the package.

package example

let _privateVar: int // Private to the package.
let exportedVar: f64
let localVar_: string // Private to the file.

const exportedConst = 100
const _privateConst = 42
const localConst_ = 12

fn _somePrivateFunction() {
    // Do something
}

fn exportedFunction() {
    // Do something
}

fn localFunction_() {
    // Do something
}

type _PrivateStruct struct {
    // Stuff
}

type ExportedStruct struct {
    // Stuff
}

type LocalStruct_ struct {
    // Stuff
}

// etc...

// You might be thinking what if you have
let _someVar_: string
// Then what will happen? In this case the compiler will default to the most private case.
// So _someVar_ will be a local variable (private to the file).
// It is not recommended to start and end with an underscore though and this will generate
// a warning.

// Underscores can be used in variable names in other contexts with no warnings, though it isn't
// always recommended.
fn someFunc(_someVar, secondVar_, _thirdVar_: int) {/- ... -/} // Nothing special about any of these args.

fn otherFunc() {
    // Stuff
    _x := 12 // Nothing special about _x.
}

// All built-in functions are in the 'nsl' package and are implicetly used in every file.
// If a function is defined with the same name as a built-in function and is in scope then
// the package must be specified.

package main
using "sample" // Includes a function called 'make'.

fn main() {
    arr := nsl::make([]int, 0, 100)
    exampleSample := sample::make(/- ... -/)
}

// In general it is a good idea to avoid using function names that are built in.
// Should using a built-in function name in a function cause a warning?

// [FUNCTIONS]

// Functions are declared with the 'fn' keyword.

fn someFunc() {
    // Do something
}

// Functions can have arguments.

fn sayHi(name: string) {
    fmt::println("Hi", name)
}

// ...and return types

fn add(a: int, b: int): int {
    return a + b
}
// ...and multiple return types
fn openFile(name: string): File, error {
    // do stuff
}

// If two or more consecutive arguments have the same type the type can be omitted for all but the
// last argument of that type.
fn add(a, b: int): int {
    return a + b
}

// Functions can have default arguments

fn add(a := 10, b := 10): int {
    return a + b
}

// Here type inference was used for the argument types but they can be specified as well.

fn add(a: int = 10, b: int = 10): int {
    return a + b
}

// Non-default arguments can't come after default arguments.

// Invalid
fn add(a := 10, b := 10, c: int): int {
    return a + b + c
}

// If a function returns something the type must be specified in the function definition.
// A function can be explicitly marked as not having a return. This is purely for the programmers
// convenience, there is no difference for the compiler. 

fn yeet(): void {
    fmt::println("Yeet")
}

// All function arguments are immutable.

fn someFunc(x: int) {
    x = 12 // Invalid
}

// If you need to change the argument for some reason you must make a copy.
fn someFunc(x: int) {
    newX := x
    newX = 12 // Valid
}

// Pointers can also be used to change the value.

fn someFunc(x: ^int) {
    newX := x
    newX^ = 12
}

let x: ^int
x^ = 2
someFunc(^x) // See section on pointers for an explination.
// x is now 12

// Functions can be variadic, meaning they can take a variable number of arguments.
// The variadic argument can be treated like a static array.
fn sum(nums: ..int): int {
    res := 0
    for (n in nums) {
        res += n
    }
    
    return res
}

sum()
sum(1, 2, 3)
sum(4, 5, 6, 7, 8)

// If a variadic function requires a minimum number of arguments to work, that can be specified with minArity(int).

#[minArity(2)]
fn sum(nums: ..int): int {
    res := 0
    for (n in nums) {
        res += n
    }
    
    return res
}

sum() // Invalid
sum(2, 2) // Valid

// maxArity(int) can also be used.
// Did you know that a function with 9 arguments is called Novenary? Well now you do!

// Arguments can't come after a variadic argument.
fn counts(cnts: ..int, type: string) // Invalid

// Nifty has function overloading, but it works differently compared to languges like c/c++.
// Instead of two functions having the same name but different arguments the functions have
// different names and are explicetly overloaded. For instance if you had a pow function for
// int, float, and double it might look like this:

fn powi(x: int, y: int): int { /- ... -/ }
fn powf(x: float, y: float): float { /- ... -/ }
fn powd(x: double, y: double): double { /- ... -/ }

fn pow overloads{powi, powf, powd}

// This is done to be more explicit and searchable as well as making the compiler simpler to develop.

// The original functions can still be called or the overloaded function can be called.
a := 2.f
b := 8.f
x := 2
y := 8

z := powi(x, y)
w := pow(x, y) // Calls powi()
v := pow(a, b) // Calls powf()
u := powf(a, b)

// The following will not compile:

fn pow(x: int, y: int): int { /- ... -/ }
fn pow(x: float, y: float): float { /- ... -/ }
fn pow(x: double, y: double): double { /- ... -/ }

// Sometimes you want to guarantee the return variable is handled.
// keep can be used to force the return variable to be used.
// Very similar to [[nodiscard]] in c++.

#[keep]
fn returnsError(): error {
    // do stuff
}

// This will force the caller to handle the returned error.

// Do something
returnsError() // Invalid
// Do more things

// Do something
err := returnsError() // Invalid, err isn't being used.
// Do more things

// Do something
unused := returnsError() // Invalid, can't use unused.
// Do more things

// Do something
err := returnsError() // Valid
if (err != null) {
    // Handle error.
}
// Do more things

// Functions can be inlined with the 'inline' keyword.
inline fn smallFastFn() { /- ... -/ }
// Or explicetly not inlined with the 'noinline' keyword.
no_inline fn bigSlowFn() { /- ... -/ }
// Let the compiler decide if it should be inlined or not. This is the default, but can be explicetly stated.
maybe_inline fn someOtherFn() { /- ... -/ }

// Functions can have one or more attribues.
#[attribName, attribName2(value)]

#[depreciated("Function 'foo' is depreciated, use 'bar' instead.")]
fn foo() { /- ... -/ }

#[depreciated("DO NOT USE")]
fn badFunc() { /- ... -/ }

#[warning("ABANDON ALL HOPE YE HWO ENTER HERE")]
fn reallyBadFunc() { /- ... -/ }

// Custom attributes can be used as well as attributes provided by the compiler.
// For instance

// TODO

// Built-in function attributes.
/- 
keep
minArity(argc: int)
maxArity(argc: int)
deprecated(msg: string = "")
maybeUnused
warning(msg: string)
static // Like static in c/c++.
requireTargetFeature(feature: string)
noReturn
traceVars(names: ..string) // Prints the values of the variables listed every time they change.
-/

// [CONTROL FLOW]

// For loops work much like they do in c/c++

for (let i = 0; i < 10; ++i) {
    // Do something
}

for (i := 0; i < 10; ++i) {
    // Do something
}

// But aslo have ranges

for (0 .. 10) { /- ... -/ } // [a, b]
for (0 ..< 10) { /- ... -/ } // [a, b)
for (0 .. 10 step 2) { /- ... -/ }
for (val i in 0 .. 10 step 2) { /- ... -/ }
for (val str in strings) { /- ... -/ }
for (val str, index in strings) { /- ... -/ }
for (let str in strings) { /- ... -/ }
for (val [key, value] in map) { /- ... -/ }
for (val [key, value, index] in map) { /- ... -/ }
// or
for (val key, value in map) { /- ... -/ }
for (val key, value, index in map) { /- ... -/ }

// While loops work like they do in c/c++.

while (condition == true) {
    // Do something
}

do {
    // Something
} while (condition == true)

// Until loops. The opposite of while loops. AKA while (!(condition == true))

until (condition == true) {
    // Do something
}

do {
    // Something
} until (condition == true)

// When statements are much like switch statements in c/c++.

x := 2
when (x) {
    1: fmt::println("one")
    2: fmt::println("two")
    3: fmt::println("three")
    else: fmt::println("???")
}

// Multiple cases can be handled at once.

when (x) {
    1, 3, 5, 7, 9: fmt::println("odd")
    2, 4, 6, 8, 10: fmt::println("even")
    else: fmt::println("???")
}

// Ranges can also be used.

when (x) {
    in 0 ..< 10: fmt::println("0 ..< 10")
    in 10 .. 100: fmt::println("10 .. 100")
    else: fmt::println("big")
}

// By default cases do not fall through. To fall through use '->'.

x := 2
when (x) {
    1 -> fmt::println("one")
    2 -> fmt::println("two")
    3: fmt::println("three")
    else: fmt::println("???")
}

// The above when statement will trigger 2 and 3.

// When is not just limited to numbers.

str := "one"
when (str) {
    "one": fmt::println("1")
    "two", "three": fmt::println("2 or 3")
    else: fmt::println("???")
}

strs0 := []string{"one", "two", "three"}
strs1 := []string{"four", "five", "six"}
str := "two"

when (str) {
    in strs0: fmt::println("1, 2, or 3")
    in strs1: fmt::println("4, 5, or 6")
    else: fmt::println("???")
}

// In general 'else' is required with when statements. 
// The exception is with enums where the values the variable can be are 
// limited and it is possible to capture all options. 
// See the enums section for an example of this.

// If statements. Work how they do in c/c++ with the addition of elif.

if (thing) {
    // Do something 1
} else if (thing2) {
    // Do something 2
} elif (thing3) {
    // Do something 3
} else {
    // Do something 4
}

// Logic operators work the same as in c/c++.
// && for and
// || for or
// ! for not
// | bit or, & bit and, ^ bit xor, ~ bit not, << lsl, >> lsr

// Ternary operator. Ternary operators can't be nested.

trueCondition ::= 12
falseCondition ::= 42
condition ::= true
x := condition ? trueCondition : falseCondition

// Labels are defined with labelName!
someLabel!

// Labels can be used with continue, break, and goto.
// Yes nifty has goto, however use of goto is disabled by default. Misuse of goto can quickly cause
// messy code but it can be very powerful in specific senarios. So I see no reason not to include it.

forever!
// Code
goto forever!

// goto can't jump to labels in other functions.

// Continue and break

for (i := 0; i < 10; ++i) {
    if (i % 2 == 0) {
        fmt::println("even")
        continue // Will exit this loop and continue.
    }
    
    fmt::print("odd")
}

found := false
for (val v in someArray) {
    if (v == target) {
        found = true
        break // Will exit this loop but will not continue.
    }
}

// Labels can be used with breal and continue as well. For instance if you have and inner and
// outer loop you can use labels to specify which loop to break/continue from. Otherwise
// nifty will break/continue from the loop the statement is in which may not be what you want.

outer!
for (i := 0; i < 100; ++i) {
    inner!
    for (j := 100; j >= 0; --j) {
        if (someCondition) {
            continue inner!
        }
        
        if (otherCondition) {
            break outer!
        }
        
        // Stuff
    }
    
    // Stuff
}

// [RANGES]

1 .. 5 // [1, 5] 1, 2, 3, 4, 5
1 ..< 5 // [1, 5) 1, 2, 3, 4

rangeVar := 0 .. 10 // type range
x := 12

if (x in range) {
    // Do something
}

// Maybe? Not sure if I want a range type or not.

// [DEFER]

// 'defer' defers the execution of code until the end of the current scope.

fn someFunc() {
    // stuff
    someFile.open("myFile.txt")
    defer someFile.close()
    // more stuff
}

// Blocks of code can be deffered as well.

fn anotherFunc() {
    defer {
        call1()
        if (condition) {
            call2()
        }
    }
    // stuff
}

// Defer statements can be stacked as well and are executed in a First In Last Out (FILO) fashion.

package main
using "nsl.fmt"

fn main() {
    for (i in 0 ..< 5) {
        defer println(i)
    }
    println("Hello world")
}

/- Will print the following:
Hello world
4
3
2
1
0
-/

// [ARRAYS]

// Nifty has both static and dynamic arrays.
// Static arrays work as follows.

arr: [5]int // Array of 5 integers, auto initialized to [0, 0, 0, 0, 0]
arr := [5]int{1, 2, 3, 4, 5} // Array of 5 integers initialized to [1, 2, 3, 4, 5]
arr := []int{1, 2, 3, 4, 5} // Array of 5 integers where the length is inferred.
arr := [5]int{5} // Array of 5 integers initialized to [5, 5, 5, 5, 5]
arr: []int // Valid, dynamic, not static.
arr: [5]int = undefined // Array of 5 integers not initialized to anything.
// Should static arrays be able to infer type?
arr := ["one", "two", "etc"]
// is the same as
arr := []string{"one", "two", "etc"}

// Arrays are 0 indexed.
arr := []int{1, 2, 3, 4, 5}
x := arr[0] // x is 1
arr[2] = 12 // [1, 2, 12, 4, 5]
// Arrays are bounds checked at compile time and runtime.
x := arr[5] // Compile time error.
arr[12] = 42 // Compile time error.

y := 5
x := arr[y] // Runtime error.

// Runtime bounds checking can be disabled at a block level with #noBoundsCheck
// This can be important in situations where performance is critical. Could lead to undefined behavior.
#noBoundsCheck {
    x = arr[y] // Y could still be out of bounds.
}

// To get the length of an array use the included len() function.
assert(len(arr) == 5) // true
// Static arrays can't have their length changed.

// Dynamic arrays are made with the included make() function.

arr := make([]int) // Dynamic array with length 0 and capacity 0
arr := make([]int, 5) // Dynamic array with length 5 and capacity 5 auto initialized to [0, 0, 0, 0, 0]
arr := make([]int, 0, 5) // Dynamic array with length 0 and capacity 5 auto initialized to []

// To get the capacity of an array use the included cap() function.
assert(cap(arr) == 5) // true

// Dynamic arrays are bounds checked as well. Can be disabled with #noBoundsCheck as well.
arr[5] = 6 // Runtime error.

// To append to an array use the included append() function.
append(&arr, 4) // [5, 5, 5, 5, 5, 4]
// Multiple values can be appended at once.
append(&arr, 6, 7, 8, 9) // [5, 5, 5, 5, 5, 4, 6, 7, 8, 9]

// Dynamic arrays can be deleted with the 'delete' operator.
delete arr // [] or should it be null?

// Additional array functionality can be found in the nsl.array package.

/- Not sure if I should keep this. -/
// To fill an array with a specified value use the included fill() function.
arr := make([]int, 0, 5) // []
fill(arr, 5) // [5, 5, 5, 5, 5] Not sure if I should keep this.

// [SLICES]

// Slices are like arrays but can be more accurately thought of as a view into the array.
// A slice is created by specifying the start index and the end index.

array[low : high]

array := []int{1, 2, 3, 4, 5, 6, 7}
arr := array[1:4] // Includes elements 1 through 3. [2, 3, 4]

// The following expressions are all equivalent.
array[0:7]
array[:7]
array[0:]
array[:]

// Slice literal.
slice := [:]int{1, 2, 3} // Creates an array with [1, 2, 3] then creates a slice for it

// Slices have length and capacity.
arr := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
slice := arr[1:5] // [1, 2, 3, 4]

len(slice) // 4
cap(slice) // 10

newSlice := slice[0:20] // Compiler error. End is out of bounds of static array.

arr := make([]int, 5) // This is a dynamic array which is actually a slice as well.
slice := arr[2:50] // Runtime error. End is out of bounds.

arr := make([]int, 5) // [0, 0, 0, 0, 0]
slice := arr[1:5] // [0, 0, 0, 0]

slice[0] = 12 // slice is now [12, 0, 0, 0] arr is now [0, 12, 0, 0, 0]

// [ENUMS]

type Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL,
    TK_FUNCTION,
    TK_VAR,
}

// The above example is just like enums in c/c++. So TK_STRING = 0, TK_NUMBER = 1 ...

type Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL = 5,
    TK_FUNCTION,
    TK_VAR,
}

// Unless otherwise specified enumerators take the value of the enumerator before them + 1.
// TK_STRING = 0, TK_NUMBER = 1, TK_BOOL = 5, TK_FUNCTION = 6 ...

// The values in an enum must be unique.

type Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL = 5,
    TK_FUNCTION,
    TK_VAR = 6, // Invalid
}

// More advanced patterns can be used as well for the increments.
type EvensForSomeReason enum {
    unused = #jot * 2,
    First,  // 2
    Second, // 4
    Third,  // 8
}

type EvensForSomeReason enum {
    First = (#jot + 1) * 2,  // 2
    Second, // 4
    Third,  // 8
}

type Permission enum {
    read = 1 << #jot, // 00000001
    write,            // 00000010
    delete,           // 00000100
}

type MemSize enum {
    unused = 1 << (#jot * 10),
    KB, // dec: 1024       bin: 00000000000000000000010000000000
    MB, // dec: 1048576    bin: 00000000000100000000000000000000
    GB, // dec: 1073741824 bin: 01000000000000000000000000000000
}

// 'jot' works much like 'iota' in go (the etymology nerds out there should love this).

// Enums can be types other than int. When this is the case all enumerators must be specified.

type Numbers enum: f64 {
    PI = 3.14159,
    E = 2.71828,
}

type Animals enum: string {
    Aardvark = "Aardvark",
    Cat = "Cat",
    Dog = "Dog",
}

// To get the name of a enumeration use the name_of operator.

num := Numbers.PI
name := name_of(num, Numbers)
fmt::println("num is {name}") // Prints 'num is PI'

// If the value can't be found it will return an empty string.
num = 3.4
name = name_of(num, Numbers) // 'name' is an empty string.

// [STRUCTS]

type Point struct {
    x: int
    y: int
}

point := {x: 12, y: 42}
let p: Point
p.x = 12
p.y = 42

// Structs can also have attributes.

#[packed] // Will not add padding
type Packed struct {
    x: f64
    y: s16
}

/- Built-in struct attributes
packed
align(alignment: int)
-/

// [OOP]

// For methods the md keyword is used so that if the impl keyword is missed by a 
// programmer or a programmer jumps to the middle of the file it is obvious that
// these are methods and not ordinary functions. 

type Collection struct {
    list: []int
    _average: float // Private variable
}

impl Collection

// Constructor
md new() {
    list = make([]int)
}

md add(num: int) {
    append(list, num)
    _calculateAverage()
}

md average(): float {
    return _average
}

// Private function
md _calculateAverage() {
    total := 0
    for (val num in list) {
        total += num
	}

	average = cast(total, f32) / cast(len(list), f32)
}

endimpl

// Optionally the name of the struct can be specified with endimpl.
endimpl Collection
// This is just to improve readability in files with multiple struct implementations.
// This does not allow for impl nesting.

collection := new Collection() // Type is ^Collection
collection := new Collection{ /- ... -/ } // Type is ^Collection also. 
// This does not call the constructor and the fields in the struct are set to their defaults.
// The values can be specified.

collection := new Collection{list: make([]int)} // Private var can't be set here.

collection->add(12) // Valid
// Is effectively the same as (but is not the same as)
add(collection, 12) // Invalid

// The calling object is implicetly passed in as 'this'.
// Because of this it is important to note that the object calling the function can be null.

collection = null
collection->add(12) // The function add will be called.

// In the function you can either check that
this != null
// or use '?' to require that the calling object not be null

md add?(num: int) {
    // Do something
}

// The compiler will error if collection can be null when the function is called.

collection->add(12) // Error! collection can be null

if (collection != null) {
    collection->add(12) // No error.
}

// If you don't allocate the object on the heap this is not an issue.

collection := Collection() // Type is Collection
collection := Collection{list: make([]int)} // Type is Collection
collection.add(12) // No check needed even if '?' is used.

// You may have noticed that I used both '->' and '.' when calling the 
// functions. Nifty works like c++ in that objects that are pointers use 
// '->' and objects that are not pointers use '.'. This is to visually 
// distinguish the two.

// Optionally an interface can be used for improved readability and to force an implementation
// to implement the functions in the interface.

type Collection interface { // TODO(Skyler): Needs work.
    new()
    add()
    average()
    _calculateAverage()
}

// If an implementation is missing one or more of those functions it will cause a compiler error.

// A struct can be implemented multiple times. So for instance a struct could exist in a library
// and you could extend it in you own code.

package someLib

type SomeStruct struct {
    // ...
}

impl SomeStruct
// ...
endimpl

// Somewhere in your code:

impl SomeStruct
// Your code ...
endimpl

// To prevent this the 'const' keyword can be used.

const impl SomeStruct
// ...
endimpl

// Your code ...

impl SomeStruct // Compiler error.

// [GENERICS]

fn add<T>(a, b: T): T {
    return a + b
}

type Point<T> struct {
    x: T
    y: T
}

// What if you wanted to store more than just int in the Collection struct above?
// Well then you would need to use generics.

type Collection<T> struct {
    list: []T
    _average: float // Private variable
}

impl Collection<T>

// Constructor
md new() {
    list = make([]T)
}

md add(num: T) {
    append(list, num)
    _calculateAverage()
}

md average(): float {
    return _average
}

// Private function
md _calculateAverage() {
    total := 0
    for (val num in list) {
        total += num
	}

	average = cast(total, f32) / cast(len(list), f32)
}

endimpl

collection := new Collection<f32>()
collection->add(12.f)

// You can also restrict methods to a certain type.

impl Collection<int>

md sum(): int {
    total := 0
    for (val num in list) {
        total += num
	}
}

endimpl

// The sum function is only available for Collection<int>.

collectionInt := new Collection<int>()
collectionF32 := new Collection<f32>()

// do stuff

sumInt := collectionInt->sum() // Valid
sumF32 := collectionF32->sum() // Comile error

// Generics are figured out at compile time so there is no runtime cost assosiated with them.

// You can specify what types are allowed to be used

type Vec3<T: int | float | double> struct {
    x: T
    y: T
    z: T
}

fn add<T: int | float | double>(a, b: Vec3<T>) { /- ... -/ }
fn sub<T: int | float | double>(a, b: Vec3<T>) { /- ... -/ }

// To make using multiple types like this easier you can use union types.

type IFD as int | float | double

// Union types like this can only be used with generics.
let num: IFD = 12 // Invalid

// The above struct and functions could be re-writen like:

type IFD as int | float | double
type Vec3<T: IFD> struct {
    x: T
    y: T
    z: T
}

fn add<T: IFD>(a, b: Vec3<T>) { /- ... -/ }
fn sub<T: IFD>(a, b: Vec3<T>) { /- ... -/ }

// If you want to make the above struct work so that any type of number can be used, but only numbers
// you can use the #number built-in macro.

type Vec3<T: #number> struct { /- ... -/ }

// Or if you only want to allow only all floating types only you can use the #decimal built-in macro.

type Vec3<T: #decimal> struct { /- ... -/ }

// I thought about having a number and decimal keyword but I don't think this would come up enough to
// merit two dedicated keywords.

// Like combined typed 'number' and 'decimal' only work with generics.
let num: #number = 12 // Invalid

// The union types work for impl  or functions as well

impl Vec3<T: int | float | double>
impl Vec3<T: IFD>
impl Vec3<T: #number>

fn add<T: int | float | double>(a, b: T) { /- ... -/ }
fn add<T: IFD>(a, b: T) { /- ... -/ }
fn add<T: #decimal>(a, b: T) { /- ... -/ }

// 'void' can't be used as a type for generics.
type Thing<T> struct { /- ... -/ }
let thing: Thing<void> // Invalid
impl Thing<void> // Invalid

// [POINTERS]

// Pointers in nifty use the Pascal syntax.
// For types '^' is on the left and indicates it is a pointer type.
// For dereferencing '^' is on the right of the variable. 
// Like c/c++ '&' is the addressof operator.

let p: ^int // p is null
x := 12
p = &x // p now points to x
y := p^ // y is 12
p^ = 42 // x is 42

// If a function takes a pointer type then ^ is used on the left of the variable
// to visually indicate that.

fn someFunc(x: ^int) {
    // Do something
}

x := 12
y: ^int = &x

someFunc(^y) // Valid
someFunc(y) // Invalid
// This is not dereferencing y or doing anything other than passing y.
// This is just so the programmer can quickly see this function is taking
// a pointer and that y could potentially be modified by the function.
// TODO: Maybe this can be optional and forced by a compiler flag?

// Nifty does not have pointer arithmetic.

let p: ^f64
// ...
p^ // Causes a panic if p is still null.

// If the compiler knows that a value is null when it is being dereferenced
// it will not compile.

let p: ^f64
p^ // Invalid

// The '?' token can be used to indicate that a pointer is not allowed to be
// null.

let p?: ^int // Invalid
let p?: ^int = new int // Valid
p = null // Invalid

// Nifty has null coalescing.

x := 12
p := &x

y := p^ ?? 12
// The above line is the same as
let y: int
if (p != null) {
    y = p^
} else {
    y = 12
}

p ??= &x
// The above line is the same as
if (p == null) {
    p = &x
}

// [FUNCTION POINTERS]

fn addFn(a, b: int): int {
    return a + b
}

fn otherFunc() {
    add := addFn // Type is ^fn(int, int): int
    add(2, 2)
}

type AddFn as fn(int, int): int

fn add(a, b: int): int { /- ... -/ }
type AddFn as type_from(add) // Also works

// [MACROS]

// Macros 

// There are multiple types of macros that can be defined.

#define SOME_CONST_MACRO

#if SOME_CONST_MACRO {
    // Code to comile if SOME_CONST_MACRO is defined (not a scope)
} else {
    // Code to compile if SOME_CONST_MACRO is not defined (not a scope)
}

// Values can not be set with #define. This just defines the macro internally in the compiler.
// To set values in a macro use #set. The values being set must be resolvable at compile time.
// It does not work like c/c++ where the macro is replaced by the expanded contents of the macro.
// They MUST resolve to a constant value. Macros are type checked as well, unlike in c/c++.

#set OTHER_CONST_MACRO 12

#if OTHER_CONST_MACRO == 12 { /- ... -/ }

// Macro values can be used by variables as well.
someVar := #OTHER_CONST_MACRO
// When macro values are used outside of other macros they must start with a '#'.
someVar := OTHER_CONST_MACRO // Invalid

// TODO

// Built in macros

#file          // replaced with the filename
#path          // replaced with the full file path
#line          // replaced with the line the macro is on
#function      // replaced with the function name the macro is in
#os            // replaced with the OS that the compiler is running on currently
#time          // replaced with the current time
#date          // replaced with the current date

#niftyVersion      // replaced with the version of the nifty compiler
#niftyVersionMajor //
#niftyVersionMinor //
#opt               // replaced with the current optimization level

#counter           // replaced by an incremented value starting at 0, it is incremented everytime it is encountered and never reset
#jot               // replaced by an incremented value starting at 0, it is incremented everytime it is encountered and reset every block

#number            // used by generics, see the section on generics for details
#decimal           // used by generics, see the section on generics for details

#noBoundsCheck

#embedBytes(path: string, limit: u64 = 0)  // Loads a file up to limit bytes and returns its contents as a []u8
#embedString(path: string, limit: u64 = 0) // Loads a file up to limit bytes and returns its contents as a string
// If limit is 0 for either then there is no limit (until you run out of RAM that is).

const RAND = #embedBytes("/dev/urandom") // Will crash the compiler, possibly your computer.
const ARR = #embedBytes("/dev/urandom", 128) // Type is [N]u8 where N is the number of elements determined at compile time.

let str: string = #embedString("hello.txt");
println(str) // hello

#error(msg: string) // Causes the compiler to error with the given message.
#warn(msg: string) // Causes the compiler to emit a warning with the given message.

// [MISC]

b := false
assert(type_from(b) == bool) // true
assert(type_of(b) == "bool") // true

c: type_from(b) // c is type bool
assert(type_from(c) == bool) // true
assert(type_of(c) == "bool") // true

num := 42.f
assert(size_of(num) == 4) // true

type Point struct {
    x: f32
    y: f32
}

assert(align_of(Point) == 4) // true

restrict // See https://en.wikipedia.org/wiki/Restrict

fn updatePointers(restrict ptrA: ^int, restrict ptrB: ^int, restrict value: ^int) {
    ptrA^ += value^
    ptrB^ += value^
}

fn updatePointers(restrict ptrA, ptrB, value: ^int) { /- ... -/ }
// It is important to note that if the function is formed like this 'restrict' only applies to ptrA.
fn updatePointers(restrict ptrA, restrict ptrB, restrict value: ^int) { /- ... -/ } // Better

// [BUILDING]

// The build file is done with TOML. The default build file name is 'nifty.toml'.
// Each build file can have multiple targets.

// A common usecase for having multiple targets is having a debug build and a production build.

project = string

[<TargetName:string>]
outputName = string 
// Name of the output.
entryPoint = string 
// The file containing 'main()'.
noEntryPoint = bool 
// Set to true to remove the requirement for a 'main()' function. Defaults to false.
noDepreciated = bool 
// Error if a function marked depreciated is used. Disabled by default.
noGoto = bool 
// Error if goto is used. Enabled by default.
debug = bool 
// Compile to debug mode. Disabled by default.
defines = [string] 
// defines = ["name=value", "name2=value2"]
errorOnWarn = bool 
// Treat warnings as errors. Disabled by default.
noWarn = bool 
// Disable warnings. Disabled by default.
optimization = string 
// Sets the optimization level. Options are none, fast, size, debug. 
// Defaults to "none". Is set to 'debug' if debug mode is enabled.
default = bool 
// Defaults to true in the first target, otherwise false. Can only be true for one target at a time.
noBoundsChecks = bool 
// Disables bounds checking for the entire program. Defaults to false.
commands = [string]
// Shell commands than can be run.
children = [string]
// List of child targets that will be run when this target is complete.

/-

nifty new // Interactive dialog to create a new nifty project

nifty build // Builds using the default build file in the current directory.
nifty build [fileName.extension] // Builds using the specified build file or source file.
nifty build [targetName] // Builds using the specified target with the default build file.
nifty build [buildFile]:[targetName] // Builds using the specified target with the specified build file.

nifty run // Takes the same arguments as 'nifty build' but builds and then runs the project.

nifty run prod // Builds and runs using 'nifty.toml' with target 'prod'.
nifty run server:debug // Builds and runs using 'server.toml' with target 'debug'

When not specifying a target the first target is used by default. Targets can optionally be marked
as the default. Only one target may be marked as default at a time.

nifty create [options] // Creates a new nifty project. Like nifty new but requires no user interaction.
nifty create name=tst

-/
