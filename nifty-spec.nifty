// [TOP]
// [HELLO WORLD]
// [COMMENTS]
// [VARIABLES]
// [TYPES]
// [PACKAGES]
// [FUNCTIONS]
// [CONTROL FLOW]
// [DEFER]
// [RANGES]
// [ARRAYS]
// [SLICES]
// [MAP]
// [ENUMS]
// [STRUCTS]
// [OOP]
// [GENERICS]
// [POINTERS]
// [FUNCTION POINTERS]
// [MEMORY]
// [OPTIONAL]
// [MACROS]
// [SIGNALS AND SLOTS]
// [MISC]
// [BUILDING] [CONFIG]
// [KEYWORDS]
// [TODO / MAYBE]

// Nifty is a new systems programming language in development.
// This file is an overview of the language and (basically) everything in here is
// subject to change. I am open to suggestions and if anything is unclear let me
// know. This file is much easier to read in vscode with the nifty extension.
// The extension is in the highlighting/vscode folder and you can copy and paste
// it into you vscode extensions folder to install it. You will have to restart
// vscode for it to go into effect.

/-

Naming conventions:

The following naming conventions are my personal preference and are what nifty uses.
These are not enforced by the compiler.

functions:          camelCase
types:              PascalCase
enum values:        PascalCase
variables:          camelCase
macros:             camelCase
macro constants     SCREAMING_SNAKE_CASE
constants:          SCREAMING_SNAKE_CASE
package names:      snake_case
keywords:           snake_case
built-in functions: snake_case
built-in types:     snake_case

The following naming conventions ARE enforced by the compiler.

Exports may not start or end with an underscore.
Privates must start with an underscore and can't end with an underscore.
Locals must end with an underscore.

-/

// [HELLO WORLD] ----------------------------------------------------------------------------------

using "nsl.fmt"

fn main() {
    println("Hello, world!")
}

// Semicolons are optional.

// [COMMENTS] -------------------------------------------------------------------------------------

// Single line comments use '//'.
// This is a comment.

/-
    Multiline comments use '/-' and '-/'
    Comments can be nested so the following is valid
-/

/-
    /-
        // bla
    -/
-/

/- Multiline comments can be on just one line too -/

/*
    C-style comments can be used as well and mixed with nifty comments.
*/

/-
    Like so
    /*
        and so
    -/
*/

// Why not just use /* */? I'm lazy, but you do you.

// [VARIABLES] ------------------------------------------------------------------------------------

// Variables are declared with the 'let' keyword.
let x = 12 // int

// The variable declaration operator can be used as well.
x := 12 // int
y := 12.f // f32
y := 12.0 // f64
y := 12.d // f64

// The types are inferred but can be specified.
let x: int = 12
x: int = 12

// If no value is specified the type must be specified
let x // Invalid
let x: int // Valid
x: int // Invalid, value must be given here.
// (Maybe this could be allowed? Don't really like this syntax for normal variables.)

// Immutable variables (runtime constants) are declared with the 'val' keyword.
val x = 12

// The constant declaration operator can be used as well.
x ::= 12

// The type is inferred for constants as well but it can also be specified.
val x: int = 12
x :: int = 12
val y: int // Invalid, immutable variables must have their value specified.

// Variables are auto initialized in Nifty.
let x: int
y := x // Valid, both will be type int with value 0

// Variables can be explicitly uninitialized
let x: int = undefined
x := undefined // Invalid, no type given
x: int = undefined // Valid

// Multiple variables can be explicitly undefined with #noAutoInit

#noAutoInit {
    let x: int
    let y: float
    let z: string
}

// x, y, and z are all defined but uninitialized.

// It is important to know that undefined is only used for declaring variables. 
// You can't check to see if a variable is undefined.
if (x == undefined) // Invalid
// Because of this undefined is NOT null
undefined == null // Invalid

// A variabled can't be later set to undefined.
x := 12
x = undefined // Invalid

buf: u32 = undefined
bufNum := buf // Invalid (???)

// Immutable variables can not be set to undefined.
val y: int = undefined // Invalid, immutable variables must have their value specified.

// Nifty does not support variable shadowing.

fn someFunc(x: int) {
    x := 12 // Invalid
}

fn someFunc() {
    someVar := 12
    {
        someVar := 42 // Invalid
    }
}

// Variables can also be unused.
// Lets say you have a function getFromTable that returns true if the key is in the
// table, false otherwise, and takes a pointer to a Value that's where the value gets
// set if it is in the table. But you don't care about the value in the table  you
// just want to know if it is there and there is no other way provided by the library.
// This is a contrived example because nifty supports multiple returns.

let value: Value = undefined
inTable := getFromTable(someTable, someKey, &value)
// This will give an error that 'val' isn't being used.

let unused: Value = undefined
inTable := getFromTable(someTable, someKey, &unused)
// 'unused' is a special variable name that lets the compiler know the variable is
// unused. In the case 'getFromTable' will be able to set the variable from inside
// the function and then the unused variable will be immediatly freed and can be
// used again.

let unused: Value = undefined
inTable := getFromTable(someTable, someKey, &unused)

let unused: Value = undefined // Because 'unused' is a special variable name it can be redefined.
inTable2 := getFromTable(someOtherTable, someOtherKey, &unused)

// If it will be used with the same type it doesn't have to be redefined.
let unused: Value = undefined
inTable := getFromTable(someTable, someKey, &unused)
inTable2 := getFromTable(someOtherTable, someOtherKey, &unused) // Also valid

// unused can't be immutable.
val unused: Value // Invalid


// [CONSTANTS] ------------------------------------------------------------------------------------

// Constants use the 'const' keyword and their value must be determined at compile time.
const x = 12
const y = someFunc() // Invalid
const z = #MACRO_CONST // Valid
const w = #constEvalFunc() // Valid

// The constant declaration operator can be used as well.

x ::= 12

// The compiler will differenciate between a runtime constant and a compile time
// constant so the same operator can be used.

// Constants can't be undefined or unused either.

// [TYPES] ----------------------------------------------------------------------------------------

// Basic Types:
char // same as u32 defaults to '\0'
int // same as s32 defaults to 0
uint // same as u32 defaults to 0
float // same as f32 defaults to 0.f
double // same as f64 defaults to 0.d

// defaults to false
bool b8 b16 b32 b64

// defaults to 0
u8 u16 u32 u64 u128
s8 s16 s32 s64 s128

//defaults to 0.0
f16 f32 f64
f128 // Not available on all platforms

//defaults to ""
string

typeid // runtime identifier for a type

rawptr // Like void* in c

// Strings will be fully supported via the standard library, the string type is very basic.
// Strings (nsl.string) will be included by default since they are so common. (Maybe?)

// Custom types can be created as follows:

type Custom as int

// Casting uses the 'cast' operator.

x: s8 = 100
y := cast(x, s32) // cast(var, type)

// To cast between two types of the same size you can uuse the 'recast' operator.

let x: f32 = 12.0
y := recast(x, u32)

// This is similar to the following pointer cast manipulation:

let x: f32 = 12.0
y := cast(^u32, &x)^

// Though recast doesn't require taking the address of the value which is not always possible.

// There is a third casting operator called 'auto_cast'.

x := 12.f
y := 19
// ...
y = auto_cast(x)

// auto_cast is convienient but potentially unsafe.

y = cast(type_from(y), x) // Like auto_cast

// Types in nifty are not implicitly converted.

x := 12
y := 42
z: f64 = x / y // Invalid
z: f64 = cast(x, f64) / cast(y, f64) // Valid
z: f64 = cast(x / y, f64) // Valid, but probably not what you want.

x := 12
if (x) { /- ... -/ } // Invalid
if (x != 0) { /- ... -/ } // Valid

b := true
if (b) { /- ... -/ } // Valid
if (b == true) { /- ... -/ } // Valid, but like why?

p: ^int = null
if (p) { /- ... -/ } // Invalid
if (p != null) { /- ... -/ } // Valid

// [PACKAGES] -------------------------------------------------------------------------------------

// All nifty programs are made of packages.

package main

use "nsl.fmt"
use "nsl.math"

fn main() {
    // Do something
}

// If no package is specified for a file then the default 'global' package is used.

using "nsl.fmt"

fn main() {
	println("Hello world!")
}

// It is fine to just use the global package for your programs. By default the global
// package is empty. Just using the global package could be an issue for larger
// programs though. The global package can't be imported and can't be used for packages
// meant to be used as 3rd party packages.

// By default the name of the package is the last element of the package 
// path, which is also the name of the package in the file. This, however,
// can be changed with the 'as' keyword

use "nsl.fmt"
use "nsl.math" as M
use "nsl.math.random"

fn main() {
    fmt::println(M::PI) // math::PI is invalid
    fmt::println(random::number())
}

// Note the 'random' is a package inside the 'math' package and must be used
// separately from 'math'.

// All items inside a package can be added to the current scope with the 'using' keyword.

use "nsl.fmt"
using fmt // All items exported from the package fmt are now in this file's scope.

fn main() {
    println("Yo whaddup?")
}

// --- --- --- --- ---

use "nsl.fmt"

fn sayHi() {
    using fmt // All items from the package fmt are now in this function's scope.
    println("Hello")
}

fn main() {
    fmt::println("Yo whaddup?")   
}

// 'using' can also be used to import the package and bring it in to the file scope.
using "nsl.fmt"

fn main() {
    println("Hello world!")
}

// If two packages are brought into the same scope and they have any exported symbols
// with the same name then the package name must be provided to avoid ambiguity.

use "nsl.fmt"
use "foo"

using fmt
using foo // Lets say that package 'foo' also has a println function.

fn main() {
    println("Ya yeet") // Invalid
    foo::println("Yote") // Valid
}

// Specific functions and types can be used from a package as well.

use { println } in "nsf.fmt"

fn main() {
    println("Hello world!")
    fmt::print("fmt is still used!\n")
}

// This will still use the fmt package but it brings just println into the current scope.
// This is a good alternative to the 'using' keyword as it decreases the chances of name collisions.

// The 'as' keyword can still be used
use { println } in "nsf.fmt" as F // fmt is now F

use { int64, float64 } in "nsl.math.random" // Multiple can be used at once.

// When importing specifics like this the 'using' keyword can not be used.

// All items not starting or ending with an underscore are exported from the package.

package example

let _privateVar: int // Private to the package.
let exportedVar: f64
let localVar_: string // Private to the file.

const exportedConst = 100
const _privateConst = 42
const localConst_ = 12

fn _somePrivateFunction() {
    // Do something
}

fn exportedFunction() {
    // Do something
}

fn localFunction_() {
    // Do something
}

type _PrivateStruct struct {
    // Stuff
}

type ExportedStruct struct {
    // Stuff
}

type LocalStruct_ struct {
    // Stuff
}

// etc...

// You might be thinking what if you have
let _someVar_: string
// Then what will happen? In this case the compiler will default to the most private case.
// So _someVar_ will be a local variable (private to the file).
// It is not recommended to start and end with an underscore though and this will generate
// a warning.

// Underscores can be used in variable names in other contexts with no warnings, though it isn't
// always recommended.
fn someFunc(_someVar, secondVar_, _thirdVar_: int) {/- ... -/} // Nothing special about any of these args.

fn otherFunc() {
    // Stuff
    _x := 12 // Nothing special about _x or x_ or _x_ here.
}

// [FUNCTIONS] ------------------------------------------------------------------------------------

// Functions are declared with the 'fn' keyword.

fn someFunc() {
    // Do something
}

// Functions can have arguments.
fn sayHi(name: string) {
    fmt::println("Hi", name)
}

// ...and return types
fn add(a: int, b: int): int {
    return a + b
}

// ...and multiple return types
fn openFile(name: string): File, error {
    // do stuff
}

fn someFunc(): int, float { /- ... -/ }
a, b := someFunc() // Valid
a := someFunc() // Invalid
a, unused := someFunc() // Valid
unused, b := someFunc() // Valid

// It is important to note that if unused is used like this the value is still being passed from the
// function. If this usecase is common and performance is critical then it is recommended to make
// another function that excludes that return value. (or could this be optimized away with the fast
// option by creating and calling modified copies of the function that omit that specific return?)

// If two or more consecutive arguments have the same type, the type can be omitted for all but the
// last argument of that type.
fn add(a, b: int): int {
    return a + b
}

// Functions can have default arguments
fn add(a := 10, b := 10): int {
    return a + b
}

// Here type inference was used for the argument types but they can be specified as well.
fn add(a: int = 10, b: int = 10): int {
    return a + b
}

// Non-default arguments can't come after default arguments.

// Invalid
fn add(a := 10, b := 10, c: int): int {
    return a + b + c
}

// If a function returns something the type must be specified in the function definition.
// A function can be explicitly marked as not having a return. This is purely for the programmers
// convenience, there is no difference for the compiler. 

fn yeet(): void {
    fmt::println("Yeet")
}

// All function arguments are immutable.
fn someFunc(x: int) {
    x = 12 // Invalid
}

// If you need to change the argument for some reason you must make a copy.
fn someFunc(x: int) {
    newX := x
    newX = 12 // Valid
}

// Pointers can also be used to change the value.
fn someFunc(x: ^int) {
    newX := x
    newX^ = 12
}

let x: ^int
x^ = 2
someFunc(^x) // See section on pointers for an explination.
// x is now 12

// Functions can be variadic, meaning they can take a variable number of arguments.
// The variadic argument can be treated like a static array.
fn sum(nums: ..int): int {
    res := 0
    for (val n in nums) {
        res += n
    }
    
    return res
}

sum()
sum(1)
sum(1, 2, 3)
sum(4, 5, 6, 7, 8)

// If a variadic function requires a minimum number of arguments to work, that can be specified with minArity(int).

#[minArity(2)]
fn sum(nums: ..int): int {
    res := 0
    for (n in nums) {
        res += n
    }
    
    return res
}

sum() // Invalid
sum(2, 2) // Valid

// maxArity(int) can also be used.
// Did you know that a function with 9 arguments is called Novenary? Well now you do!

// Arguments can't come after a variadic argument.
fn counts(cnts: ..int, type: string) // Invalid

// Nifty has function overloading, but it works differently compared to languges like c/c++.
// Instead of two functions having the same name but different arguments the functions have
// different names and are explicetly overloaded. For instance if you had a pow function for
// int, float, and double it might look like this:

fn powi(x: int, y: int): int { /- ... -/ }
fn powf(x: float, y: float): float { /- ... -/ }
fn powd(x: double, y: double): double { /- ... -/ }

fn pow overloads{powi, powf, powd}

// This is done to be more explicit and searchable as well as making the compiler simpler to develop.

// The original functions can still be called or the overloaded function can be called.
a := 2.f
b := 8.f
x := 2
y := 8

z := powi(x, y)
w := pow(x, y) // Calls powi()
v := pow(a, b) // Calls powf()
u := powf(a, b)

// The following will not compile:

fn pow(x: int, y: int): int { /- ... -/ }
fn pow(x: float, y: float): float { /- ... -/ }
fn pow(x: double, y: double): double { /- ... -/ }

// Sometimes you want to guarantee the return variable is handled.
// keep can be used to force the return variable to be used.
// Very similar to [[nodiscard]] in c++.

#[keep]
fn returnsError(): error {
    // do stuff
}

// This will force the caller to handle the returned error.

// Do something
returnsError() // Invalid
// Do more things

// Do something
err := returnsError() // Invalid, err isn't being used.
// Do more things

// Do something
unused := returnsError() // Invalid, can't use unused.
// Do more things

// Do something
err := returnsError() // Valid
if (err != null) {
    // Handle error.
}
// Do more things

// Functions can be inlined with the 'inline' attribute.
#[inline]
fn smallFastFn() { /- ... -/ }
// Or explicetly not inlined with the 'noInline' attribute.
#[noInline]
fn bigSlowFn() { /- ... -/ }
// Let the compiler decide if it should be inlined or not. This is the default, but can be explicetly stated.
#[maybeInline]
fn someOtherFn() { /- ... -/ }

// Functions can have one or more attribues.
#[attribName, attribName2(value)]

#[depreciated("Function 'foo' is depreciated, use 'bar' instead.")]
fn foo() { /- ... -/ }

#[depreciated("DO NOT USE")]
fn badFunc() { /- ... -/ }

// With deprecatedAfter the depreciated warning will onlt be shown after the given date.
#[deprecated("Use X instead."), deprecatedAfter("2023-10-20")] // yyyy-mm-dd
fn eventuallyDepreciated() { /- ... -/ }

// deprecatedAfter can be used on its own. The equivalent of using deprecated with no message specified.
#[deprecatedAfter("2023-10-20")] // yyyy-mm-dd
fn eventuallyDepreciated() { /- ... -/ }

#[warning("ABANDON ALL HOPE YE WHO ENTER HERE")]
fn reallyBadFunc() { /- ... -/ }

#[keep, maybeUnused]
fn bla(): int { /- ... -/ }

// optionalOk allows skipping the last return value which must be a bool.
#[optionalOk]
md get(key: string): int, bool {
    // Code here ...
    
    if (!found) {
        return 0, false
    }
    
    return value, true
}

var := container.get("thing") // Valid

// Custom attributes can be used as well as attributes provided by the compiler.
// For instance

// TODO

// Built-in function attributes.
/- 
keep
optionalOk
minArity(argc: int)
maxArity(argc: int)
deprecated(msg: string = "")
deprecatedAfter(date: string) // yyyy-mm-dd
maybeUnused
warning(msg: string)
static // Like static in c/c++.
requireTargetFeature(feature: string)
noReturn
inline
noInline
maybeInline
traceVars(names: ..string) // Prints the values of the variables listed every time they change.
                           // This is meant for debugging and will be relatively slow.

// Called at the end of the callers scope.
deferredIn(function: fn) // Receives the same paramaters as the called function.
deferredOut(function: fn) // Receives the results of the called function.
deferredInOut(function: fn) // Receives both the input and output of the called function.
deferredNone(function: fn) // Receives no input.
These can be useful but are not always recommended as they can make it not obvious why a function
is being called without further investigation.

linkName(name: string)
-/

#[linkName("llvm.cos.f64")]
fn cosf64(f64): f64 undefined

// [CONTROL FLOW] ---------------------------------------------------------------------------------

// For loops work much like they do in c/c++

for (let i = 0; i < 10; ++i) {
    // Do something
}

for (i := 0; i < 10; ++i) {
    // Do something
}

// But aslo have ranges

for (0 ..= 10) { /- ... -/ } // [a, b]
for (0 ..< 10) { /- ... -/ } // [a, b)
for (0 ..= 10 step 2) { /- ... -/ }
for (val i in 0 ..< 10)
for (val i in 0 ..= 10 step 2) { /- ... -/ }
for (val str in strings) { /- ... -/ }
for (val str, index in strings) { /- ... -/ }
for (let str in strings) { /- ... -/ }
for (val key, value in map) { /- ... -/ }
for (val key, value, index in map) { /- ... -/ }

// While loops work like they do in c/c++.

while (condition == true) {
    // Do something
}

do {
    // Something
} while (condition == true)

// Until loops. The opposite of while loops. AKA while (!(condition == true))

until (condition == true) {
    // Do something
}

do {
    // Something
} until (condition == true)

// When statements are much like switch statements in c/c++.

x := 2
when (x) {
    1: fmt::println("one")
    2: fmt::println("two")
    3: fmt::println("three")
    else: fmt::println("???")
}

// Multiple cases can be handled at once.

when (x) {
    1, 3, 5, 7, 9: fmt::println("odd")
    2, 4, 6, 8, 10: fmt::println("even")
    else: fmt::println("???")
}

// Ranges can also be used.

when (x) {
    in 0 ..< 10: fmt::println("0 ..< 10")
    in 10 ..= 100: fmt::println("10 ..= 100")
    else: fmt::println("big")
}

// By default cases do not fall through. To fall through use '->'.

x := 2
when (x) {
    1 -> fmt::println("one")
    2 -> fmt::println("two")
    3: fmt::println("three")
    else: fmt::println("???")
}

// The above when statement will trigger 2 and 3.

// When is not just limited to numbers.

str := "one"
when (str) {
    "one": fmt::println("1")
    "two", "three": fmt::println("2 or 3")
    else: fmt::println("???")
}

strs0 := []string{"one", "two", "three"}
strs1 := []string{"four", "five", "six"}
str := "two"

when (str) {
    in strs0: fmt::println("1, 2, or 3")
    in strs1: fmt::println("4, 5, or 6")
    else: fmt::println("???")
}

// In general 'else' is required with when statements. 
// The exception is with enums where the values the variable can be are 
// limited and it is possible to capture all options. 
// See the enums section for an example of this.

// If statements. Work how they do in c/c++ with the addition of elif.

if (thing) {
    // Do something 1
} else if (thing2) {
    // Do something 2
} elif (thing3) {
    // Do something 3
} else {
    // Do something 4
}

// Logic operators work the same as in c/c++.
// && for and
// || for or
// ! for not
// | bit or, & bit and, ~ bit xor(binary), ~ bit not(unary), << lsl, >> lsr

// Ternary operator. Ternary operators can't be nested.

valueIfTrue ::= 12
valueIfFale ::= 42
condition := true
x := condition ? valueIfTrue : valueIfFale
assert(x == 12) // true

condition = false
x = condition ? valueIfTrue : valueIfFale
assert(x == 42) // true

// Labels are defined with labelName!
someLabel!

// Labels can be used with continue, break, and goto.
// Yes nifty has goto, however use of goto is disabled by default. Misuse of goto can quickly cause
// messy code but it can be very powerful in specific senarios. So I see no reason not to include it.

forever!
// Code
goto forever!

// goto can't jump to labels in other functions.

// Continue and break

for (i := 0; i < 10; ++i) {
    if (i % 2 == 0) {
        fmt::println("even")
        continue // Will exit this loop and continue the loop.
    }
    
    fmt::print("odd")
}

found := false
for (val v in someArray) {
    if (v == target) {
        found = true
        break // Will exit this loop but will not continue the loop.
    }
}

// Labels can be used with breal and continue as well. For instance if you have and inner and
// outer loop you can use labels to specify which loop to break/continue from. Otherwise
// nifty will break/continue from the loop the statement is in which may not be what you want.

outer!
for (i := 0; i < 100; ++i) {
    inner!
    for (j := 100; j >= 0; --j) {
        if (someCondition) {
            continue inner!
        }
        
        if (otherCondition) {
            break outer!
        }
        
        // Stuff
    }
    
    // Stuff
}

// [RANGES] ---------------------------------------------------------------------------------------

1 ..= 5 // [1, 5] 1, 2, 3, 4, 5
1 ..< 5 // [1, 5) 1, 2, 3, 4

rangeVar := 0 ..= 10 // type range
x := 12

if (x in range) {
    // Do something
}

// Maybe? Not sure if I want a range type or not.

// [DEFER] ----------------------------------------------------------------------------------------

// 'defer' defers the execution of code until the end of the current scope.

fn someFunc() {
    // stuff
    someFile.open("myFile.txt")
    defer someFile.close()
    // more stuff
}

// Blocks of code can be deffered as well.

fn anotherFunc() {
    defer {
        call1()
        if (condition) {
            call2()
        }
    }
    // stuff
}

// Defer statements can be stacked as well and are executed in a First In Last Out (FILO) fashion.

package main
using "nsl.fmt"

fn main() {
    for (val i in 0 ..< 5) {
        defer println(i)
    }
    println("Hello world")
}

/- Will print the following:
Hello world
4
3
2
1
0
-/

// [ARRAYS] ---------------------------------------------------------------------------------------

let arr: [5]int // Array of 5 integers, auto initialized to [0, 0, 0, 0, 0]
arr := [5]int{1, 2, 3, 4, 5} // Array of 5 integers initialized to [1, 2, 3, 4, 5]
arr := []int{1, 2, 3, 4, 5} // Array of 5 integers where the length is inferred.
arr := [1, 2, 3, 4, 5] // Array of 5 integers where the length and type are inferred.
arr := [5]int{5} // Array of 5 integers initialized to [5, 5, 5, 5, 5]
arr := [5]int{5, 6} // Array of 5 integers initialized to [5, 6, 0, 0, 0] or should this not compile?
arr: [5]int = undefined // Array of 5 integers not initialized to anything.

let arr: []int // Array with length 0 and size 0
arr := []int{} // Array with length 0 and size 0
arr := []int{size: 100} // Array with length 0 and size 100 initialized to []
arr := []int{len: 3, size: 100} // Array with length 5 and size 100 initialized to [0, 0, 0]
arr := []int{len: 3, size: 100: init: 2} // Array with length 5 and size 100 initialized to [2, 2, 2]
arr := []int{len: 3, size: 100: init: [1, 2, 3]} // Array with length 5 and size 100 initialized to [1, 2, 3]

// Arrays are 0 indexed.
arr := [1, 2, 3, 4, 5]
x := arr[0] // x is 1
arr[2] = 12 // [1, 2, 12, 4, 5]

// Arrays are bounds checked at compile time (where possible) and runtime.
x := arr[5] // Compile time error.
arr[12] = 42 // Compile time error.

y := 5
x := arr[y] // Runtime error.

// Runtime bounds checking can be disabled at a block level with #noBoundsCheck
// This can be important in situations where performance is critical. Could lead to undefined behavior.
#noBoundsCheck {
    x = arr[y] // y could still be out of bounds.
}

// To get the length of an array use the included len() function.
assert(arr.len() == 5) // true
// To get the capacity (size - length) of an array use the included cap() function.
assert(arr.cap() == 5) // true
// To get the size of an array use the included size() function.
assert(arr.size() == 5) // true

arr := []int{len: 5, size: 100, init: 12} // [12, 12, 12, 12, 12]
assert(arr.len() == 5) // true
assert(arr.size() == 100) // true
assert(arr.cap() == 95) // true

// To append to an array use the included append() function.
arr.append(4) // [5, 5, 5, 5, 5, 4]
// Multiple values can be appended at once.
arr.append(6, 7, 8, 9) // [5, 5, 5, 5, 5, 4, 6, 7, 8, 9]
arr.prepend(12) // [12, 5, 5, 5, 5, 5, 4, 6, 7, 8, 9]

arr.clear() // []

arr := new []int // Pointer to dynamic array
// ...
delete arr // [] now pointer to empty array

arr? := new []int
// ...
delete arr // null (?)

// Arrays can be multidimensional.
let arr: [][]int // 2D array of int
arr := {
    {1, 2, 3, 4},
    {5, 6, 7, 8}
}

arr[1][2] // 7
arr[0] // [1, 2, 3, 4]

// [SLICES] ---------------------------------------------------------------------------------------

// Slices are like arrays but can be more accurately thought of as a view into the array.
// A slice is created by specifying the start index and the end index.

array[low : high]

array := [1, 2, 3, 4, 5, 6, 7]
arr := array[1:4] // Includes elements 1 through 3. [2, 3, 4]

// The following expressions are all equivalent.
array[0:7]
array[:7]
array[0:]
array[:]

// Slice literal.
slice := [:]int{1, 2, 3} // Creates an array with [1, 2, 3] then creates a slice for it

// Slices have length, size and capacity.
arr := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
slice := arr[1:5] // [1, 2, 3, 4]

slice.len() // 4
slice.size() // 4
slice.cap() // 0

newSlice := slice[0:20] // Compiler error. End is out of bounds of the array.

arr := [5]int{0} // [0, 0, 0, 0, 0]
slice := arr[1:5] // [0, 0, 0, 0]

slice[0] = 12 // slice is now [12, 0, 0, 0] arr is now [0, 12, 0, 0, 0]

// [MAP] ------------------------------------------------------------------------------------------

// Nifty has a built-in map type.

m := Map<string, int>() // The default value of a map is an empty map.
defer delete m
m["Alice"] = 12
fmt::println(m["Alice"]) // Prints 12

// To insert or update a value use
m[key] = value
 
// To get a value use
value = m[key]

// If the keey is not in the map then the default value of the type is returned.
m := Map<string, int>()
i := m["index"] // i will be 0

// Checking if the key exists can be done in two ways:
m := Map<string, int>()
if (i, ok := m["index"]; ok) { /- ... -/ } // i will be 0, ok will be false

// or

ok := "index" in m // ok will be false
if (ok) { /- ... -/ }

// The first example is the comma ok idiom from go and is the same as:
i, ok := m["index"]
if (ok) { /- ... -/ }

// Maps can be initialized with map literals.

m := Map<string, int>{
    "Alice": 12,
    "Bob": 42
}

m := Map<string, int>{} // Valid, empty map
let m: Map<string, int> // Valid, empty map
m := Map<string, int>() // Valid, empty map

// len() can be used to get the number of items in a map
assert(m.len() == 2) // true

// To remove a key/value pair use the 'remove' function:
m.remove(key)

type Point struct { x, y: f64 }
m := Map<string, Point>{
    "zero": {},
    "start": {12.f, 42.f},
    "stop": {142.f, 96.f}
}

// Because the value type is specified it is ok to not include the name of the fields.
// Though it can be included.

m := Map<string, Point>{
    "zero": Point{},
    "start": Point{12.f, 42.f},
    "stop": Point{x: 142.f, y: 96.f}
}

// [ENUMS] ----------------------------------------------------------------------------------------

type Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL,
    TK_FUNCTION,
    TK_VAR,
}

// The above example is just like enums in c/c++. So TK_STRING = 0, TK_NUMBER = 1 ...

type Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL = 5,
    TK_FUNCTION,
    TK_VAR,
}

// Unless otherwise specified enumerators take the value of the enumerator before them + 1.
// TK_STRING = 0, TK_NUMBER = 1, TK_BOOL = 5, TK_FUNCTION = 6 ...

// The values in an enum must be unique.

type Token enum {
    TK_STRING,
    TK_NUMBER,
    TK_BOOL = 5,
    TK_FUNCTION,
    TK_VAR = 6, // Invalid
}

// More advanced patterns can be used as well for the increments.
type EvensForSomeReason enum {
    unused = #jot * 2,
    First,  // 2
    Second, // 4
    Third,  // 8
}

type EvensForSomeReason enum {
    First = (#jot + 1) * 2,  // 2
    Second, // 4
    Third,  // 8
}

type Permission enum {
    read = 1 << #jot, // 00000001
    write,            // 00000010
    delete,           // 00000100
}

type MemSize enum {
    unused = 1 << (#jot * 10),
    KB, // dec: 1024       bin: 00000000000000000000010000000000
    MB, // dec: 1048576    bin: 00000000000100000000000000000000
    GB, // dec: 1073741824 bin: 01000000000000000000000000000000
}

// 'jot' works much like 'iota' in go (the etymology nerds out there should love this).

// Enums can be types other than int. When this is the case all enumerators must be specified.

type Numbers enum: f64 {
    PI = 3.14159,
    E = 2.71828,
}

type Animals enum: string {
    Aardvark = "Aardvark",
    Cat = "Cat",
    Dog = "Dog",
}

// To get the name of a enumeration use the name_of operator.

num := Numbers.PI
name := name_of(num, Numbers)
fmt::println("num is {name}") // Prints 'num is PI'

// If the value can't be found it will return an empty string.
num = 3.4
name = name_of(num, Numbers) // 'name' is an empty string.

// using can be used on enums.

type Numbers enum: f64 {
    PI = 3.14159,
    E = 2.71828,
}

// ...

using Numbers // Bring Numbers enumerations into the current scope.

num := PI // Valid
e := Numbers.E // Unlike with packages the name can still be used with using.

// [STRUCTS] --------------------------------------------------------------------------------------

type Point struct {
    x: int
    y: int
}

let p: Point
p.x = 12
p.y = 42

point: Point = {x: 12, y: 42} // Valid
point: Point = {12, 42} // Valid
point: Point = {} // Valid, x and y are set to 0, same as let point: Point
point: Point = {12} // Invalid, either all values must be set or no values are set
point := Point{x: 12, y: 42} // Valid
point := Point{x: 12} // Valid, y is 0
point := {x: 12, y: 42} // Invalid, other types could have an x and y.

// Default values can be given for strcut fields.

type Point3D struct {
    x: f64 = 100.f
    y: f64 = 100.f
    z: f64 = 1.f
}

// This allows structs to be uninitialized.

type Point3D struct {
    x: f64 = undefined
    y: f64 = undefined
    z: f64 = undefined
}

// If fields in a struct are of the same type then they can be on the same line.

type Point3D struct { x, y, z: f64 }
point := Point3D{y: 12.f, Z: 42.f} // Valid

// You can also set fields on the same line to the same value.
type Point3D struct { x, y, z: f64 = 100.f }
type Point3D struct { x, y, z: f64 = undefined }

// Structs can also have attributes.

#[packed] // Will not add padding
type Packed struct {
    x: f64
    y: s16
}

/- Built-in struct attributes
packed
align(alignment: int)
-/

type Person struct {
    id:        int        `json:"id",norm:"index"`
    name:      string     `json:"name"`
    holding:   []string   `json:"holding",omitempty`
    createdAt: time::Time `json:"created_at"`
}

// [OOP] ------------------------------------------------------------------------------------------

// For methods the md keyword is used so that if the impl keyword is missed by a 
// programmer or a programmer jumps to the middle of the file it is obvious that
// these are methods and not ordinary functions. The fn keyword can be used as 
// well. The md keyword can't be used outside an impl.

type Collection struct {
    list: []int
    _average: float // Private variable
}

impl Collection

// Constructor
// Return type for the constructor is implicitly determined and 'this' is implicitly returned.
md new(size := 0) {
    list = []int{size: size}
}

md add(num: int) {
    append(list, num)
    _calculateAverage()
}

md average(): float {
    return _average
}

// Private function
md _calculateAverage() {
    total := 0
    for (val num in list) {
        total += num
	}

	average = cast(total, f32) / cast(len(list), f32)
}

endimpl

// Optionally the name of the struct can be specified with endimpl.
endimpl Collection
// This is just to improve readability in files with multiple struct implementations.
// This does not allow for impl nesting.

collection := new Collection() // Type is ^Collection. Calls constructor.
collection := new Collection{ /- ... -/ } // Type is ^Collection also. 
// This does not call the constructor and the fields in the struct are set to their defaults.
// The values can be specified.

// To indicate that collection can be null
let collection?: ^Collection = new Collection()
// Or more succinctly
let collection? = new Collection()
collection? := new Collection()

collection := new Collection{list: []int{}} // Private variables can't be set here.

collection->add(12) // Valid
// Is effectively the same as (but is not the same as)
add(collection, 12) // Invalid

// The calling object is implicetly passed in as 'this'.
// Because of this it is important to note that the object calling the function can be null. (???)

collection = null
collection->add(12) // The function add will not be called. This will panic.???

// In the function you can either check that
this != null
// or use '?' to require that the calling object not be null

md add?(num: int) {
    // Do something
}

// The compiler will error if collection can be null when the function is called.

collection->add(12) // Error! collection can be null

if (collection != null) {
    collection->add(12) // No error.
}

// If you don't allocate the object on the heap this is not an issue.

collection := Collection() // Type is Collection. Constructor is called.
collection := Collection{list: []int{}} // Type is Collection. Constructor is not called.
collection.add(12) // No check needed even if '?' is used.

// You may have noticed that I used both '->' and '.' when calling the 
// functions. Nifty works like c++ in that objects that are pointers use 
// '->' and objects that are not pointers use '.'. This is to visually 
// distinguish the two.

// Optionally an interface can be used for improved readability and to force an implementation
// to implement the functions/variables in the interface.

type Collection interface {
    new(int) // Return type for the constructor is implicitly determined.
    add(int) // Argument name is optional.
    average(): float
    _calculateAverage(): void // Using void is optional.
    list: []int
    _average: float
}

// Note that using the fn or md keywords is optional here. 

// If an implementation is missing one or more of those functions it will cause a compiler error.
// The above interface only applies to implementation of the 'Collection' struct.

// Behaviors are a a way to define shared behavior. To indicate that an implementation does a
// certain behavior the 'does' keyword is used. Implementations can do one or more behaviors
// unlike 'interface' which is only applied to the specified struct.

// If an implementation does a behavior then all the functions in the behavior must be 
// implemented or there will be a compiler error. If an implementation does multiple behaviors
// with conflicting function names then there will be a compiler error. If a behavior and an
// interface have conflicting function names there will be a compiler error.

use "nsl.math"

type Rect struct { w, h: f64 }
type Circle struct { r: f64 }

type Geometry behavior {
    area(): f64
    perim(): f64
}

type Arc behavior {
    partialArea(percent: f64): f64 // The argument name is optional here.
}

impl Rect does Geometry

md area(): f64 {
    return w * h
}

md perim(): f64 {
    return 2 * w + 2 * h
}

endimpl

impl Circle does Geometry, Arc

md area(): f64 {
    return math::PI * r * r
}

md perim(): f64 {
    return 2 * math::PI * r
}

md partialArea(percent: f64): f64 {
    return area() * percent
}

endimpl

// A struct can be implemented multiple times. So for instance a struct could exist in a library
// and you could extend it in you own code.

package some_lib

type SomeStruct struct {
    // ...
}

impl SomeStruct
// ...
endimpl

// Somewhere in your code:

impl SomeStruct
// Your code ...
endimpl

// To prevent this the 'constimpl' keyword can be used.

constimpl SomeStruct
// ...
endimpl

// Your code ...

impl SomeStruct // Compiler error.

// To print a custom type implement the str() function.

type Color struct { r, g, b: u8 }

impl Color

md str(): string {
    return `{${r}, ${g}, ${b}}`
}

endimpl

// [GENERICS] -------------------------------------------------------------------------------------

fn add<T>(a, b: T): T {
    return a + b
}

type Point<T> struct {
    x: T
    y: T
}

// What if you wanted to store more than just int in the Collection struct above?
// Well then you would need to use generics.

type Collection<T> struct {
    list: []T
    _average: float // Private variable
}

impl Collection<T>

// Constructor
md new(size := 0) {
    list = []T{size: size}
}

md add(num: T) {
    append(list, num)
    _calculateAverage()
}

md average(): float {
    return _average
}

// Private function
md _calculateAverage() {
    total := 0
    for (val num in list) {
        total += num
	}

	average = cast(total, f32) / cast(len(list), f32)
}

endimpl

collection := new Collection<f32>()
collection->add(12.f)

// You can also restrict methods to a certain type.

impl Collection<int>

md sum(): int {
    total := 0
    for (val num in list) {
        total += num
	}
}

endimpl

// The sum function is only available for Collection<int>.

collectionInt := new Collection<int>()
collectionF32 := new Collection<f32>()

// do stuff

sumInt := collectionInt->sum() // Valid
sumF32 := collectionF32->sum() // Comile error

// Generics are figured out at compile time so there is no runtime cost assosiated with them.

// You can specify what types are allowed to be used

type Vec3<T: int | float | double> struct {
    x: T
    y: T
    z: T
}

fn add<T: int | float | double>(a, b: Vec3<T>) { /- ... -/ }
fn sub<T: int | float | double>(a, b: Vec3<T>) { /- ... -/ }

// To make using multiple types like this easier you can use union types.

type IFD as int | float | double

// Union types like this can only be used with generics.
let num: IFD = 12 // Invalid

// The above struct and functions could be re-writen like:

type IFD as int | float | double
type Vec3<T: IFD> struct {
    x: T
    y: T
    z: T
}

fn add<T: IFD>(a, b: Vec3<T>) { /- ... -/ }
fn sub<T: IFD>(a, b: Vec3<T>) { /- ... -/ }

// If you want to make the above struct work so that any type of number can be used, but only numbers
// you can use the #number built-in macro.
type Vec3<T: #number> struct { /- ... -/ }

// Or if you only want to allow only all floating types only you can use the #decimal built-in macro.
type Vec3<T: #decimal> struct { /- ... -/ }

// Or if you only want to allow only all integer types only you can use the #integer built-in macro.
type Vec3<T: #integer> struct { /- ... -/ }

// I thought about having a number, decimal, and integer keywords but I don't think this would come up
// enough to merit three dedicated keywords.

// Like combined typed 'number' and 'decimal' only work with generics.
let num: #number = 12 // Invalid

// The union types work for impl  or functions as well

impl Vec3<T: int | float | double>
impl Vec3<T: IFD>
impl Vec3<T: #number>

fn add<T: int | float | double>(a, b: T) { /- ... -/ }
fn add<T: IFD>(a, b: T) { /- ... -/ }
fn add<T: #decimal>(a, b: T) { /- ... -/ }

// Type 'void' can not be used as a type for generics.
type Thing<T> struct { /- ... -/ }
let thing: Thing<void> // Invalid
impl Thing<void> // Invalid


// TODO: How to make a generic function only take non nullable pointers?

// [POINTERS] -------------------------------------------------------------------------------------

// Pointers in nifty use the Pascal syntax.
// For types '^' is on the left and indicates it is a pointer type.
// For dereferencing '^' is on the right of the variable. 
// Like c/c++ '&' is the addressof operator.

let p: ^int = undefined
x := 12
p = &x // p now points to x
y := p^ // y is 12
p^ = 42 // x is 42

// By default pointers can't be null.
let ptr: ^int = null // Invalid

// To allow a pointer to be null use '?'.
let ptr?: ^int = null // Valid
let ptr?: ^int // ptr is null

// To return a nullable pointer '?' is used as well.
fn returnsNullable(): ?^int, bool { /- ... -/ }

// If a function takes a pointer type then ^ is used on the left of the variable
// to visually indicate that.

fn someFunc(x: ^int) {
    // Do something
}

x := 12
y: ^int = &x

someFunc(^y) // Valid
someFunc(y) // Invalid
// This is not dereferencing y or doing anything other than passing y.
// This is just so the programmer can quickly see this function is taking
// a pointer and that y could potentially be modified by the function.
// TODO: Is this annoying?
// TODO: Maybe this can be optional and forced by a compiler flag?

// Nifty does not have pointer arithmetic.

let p?: ^f64
// ...
p^ // Causes a panic if p is still null.

// If the compiler knows that a value is null when it is being dereferenced
// it will not compile.

let p?: ^f64
p^ // Invalid

// Nifty has null coalescing.

x := 12
p := &x

y := p^ ?? 12
// The above line is the same as
let y: int
if (p != null) {
    y = p^
} else {
    y = 12
}

p ??= &x
// The above line is the same as
if (p == null) {
    p = &x
}

// [FUNCTION POINTERS] ----------------------------------------------------------------------------

fn addFn(a, b: int): int {
    return a + b
}

fn otherFunc() {
    add := addFn // Type is ^fn(int, int): int
    add(2, 2)
}

type AddFn as fn(int, int): int

fn add(a, b: int): int { /- ... -/ }
type AddFn as type_from(add) // Also works

// [MEMORY] ---------------------------------------------------------------------------------------

// Custom allocators can be used with the 'new' keyword.

ptr := new:CustomAlloc int

// To create a custom allocator you must use constimpl and at a minimum have an alloc() function
// and a free() function.

type CustomAlloc struct {} // The struct doesn't (technically) need any fields.

constimpl CustomAlloc

md alloc() { /- ... -/ }
md free()  { /- ... -/ }

endimpl

// [OPTIONAL] -------------------------------------------------------------------------------------

// Nifty has a built-in optional type that can be used. Optional, Value, Empty are used by default.
// The idea is to have a way to have a variable with no value without crashing or panicking in any
// situation. Optional can only cause a panic if the programmer explicitly wants to panic.

fn someFunc(): Optional<string> {
    // ...
    if (someCondition) {
        return "a string" // Return does have a value.
    }
    
    return Empty // Return doen't have a value.
}

const result = someFunc()
str := result.valueOr("yeet") // str will be yeet if result has no value, otherwise it is the contained value.

str := when (result) {
    Value: result.value() // The value() function can only be used in a when statement in the 'Value' case.
    Empty: "yeet"
}
// Both the Value and Empty cases must be handled in a when statement.

let str: string
when (result) {
    Value: str = result.value()
    Empty: fmt::println('Empty')
}

// Instead of writing out Optional a question mark can be used instead.
fn someFunc(): string? { /- ... -/ } // Same as above.

// Optionals can be in function arguments too.
fn anotherFunc(arg1: string?, arg2: string, arg3: string?): int
// Because optionals still have to be passed you can have a non-optional after an optional.

// Default values can be used as well.
fn anotherFunc(arg1: string?, arg2: string, arg3: string? = Empty): int

// You can't return an optional with a nullable pointer.
fn invalid(): ?^int? { /- ... -/ } // Invalid

// Nor can a function take optionals with nullable pointers.
fn invalid(x?: ^int?) { /- ... -/ } // Invalid

// Optionals can be used with pointers.

let p: ^int = new int // p can't be null
let opt: Optional<^int> // Pointers in optionals can't be null. Default for Optional is Empty.
let opt: ^int? // Same as the above line
let opt: = Optional<^int>(p) // Create an optional and set its value to p.
let opt: = Optional<type_from(p)>(p) // If p were a more complicated type.

opt.set(p) // Value is now p.

let nullable?: ^int
opt.set(nullable) // Invalid. This pointer could be null so it can't be in an optional.

// Optionals can't be of type 'void'.
fn returnsNothing(): void? // Invalid

// Included functions.
md value<T>(): T // Can only be used in a when statement in the 'Value' case.
md valueOr<T>(other: T): T // If the optional is Empty then other is returned. The other value can't be null.
md valueOrElse<T>(func fn: T ): T // If the optional is Empty then other is returned.
md valueOrDefault<T>(): T // If the optional is Empty then the default value for the type is returned.
md valueOrPanic(msg: string): T // Panics with the given message if the optional is Empty, otherwise returns the value.

md hasValue(): bool // Returns true if it has a value.
md isEmpty(): bool  // Returns true if it is Empty.
md clear() // Set to Empty.
md set(value: T) // Set the value of the optional.

// [MACROS] ---------------------------------------------------------------------------------------

// Macros 

// There are multiple types of macros that can be defined.

#define SOME_CONST_MACRO

#if SOME_CONST_MACRO {
    // Code to comile if SOME_CONST_MACRO is defined (not a scope)
} else {
    // Code to compile if SOME_CONST_MACRO is not defined (not a scope)
}

// Values can not be set with #define. This just defines the macro internally in the compiler.
// To set values in a macro use #set. The values being set must be resolvable at compile time.
// It does not work like c/c++ where the macro is replaced by the expanded contents of the macro.
// They MUST resolve to a constant value. Macros are type checked as well, unlike in c/c++.

#set OTHER_CONST_MACRO 12

#if OTHER_CONST_MACRO == 12 { /- ... -/ }

// Macro values can be used by variables as well.
someVar := #OTHER_CONST_MACRO
// When macro values are used outside of other macros they must start with a '#'.
someVar := OTHER_CONST_MACRO // Invalid

// TODO

// Built in macros

#file          // replaced with the filename
#path          // replaced with the full file path
#line          // replaced with the line the macro is on
#lineRaw       // usually the same as #line but if in a macro will show the line in the macro, not where it is used
#function      // replaced with the function name the macro is in
#package       // replaced with the name of the current package
#os            // replaced with the OS that the compiler is running on currently
#buildIf()     // will build the file/block only if the argument is defined
#buildIfAny()  // will build the file/block only if one or more of the arguments is defined
#buildIfNot()  // will build the file/block only if none of the arguments are defined
#buildIfAll()  // will build the file/block only if all of the arguments are defined
#time          // replaced with the current time
#date          // replaced with the current date

#niftyVersion      // replaced with the version of the nifty compiler
#niftyVersionMajor //
#niftyVersionMinor //
#opt               // replaced with the current optimization level

#counter           // replaced by an incremented value starting at 0, it is incremented everytime it is encountered and never reset
#jot               // replaced by an incremented value starting at 0, it is incremented everytime it is encountered and reset every block

#number            // used by generics, see the section on generics for details
#decimal           // used by generics, see the section on generics for details
#integer           // used by generics, see the section on generics for details

#noBoundsCheck     // does not check bounds
#noAutoInit        // does not auto init variables

#embedBytes(path: string, limit: u64 = 0, compress: string = "")  // Loads a file up to limit bytes and returns its contents as a []u8
#embedString(path: string, limit: u64 = 0, compress: string = "") // Loads a file up to limit bytes and returns its contents as a string
// If compress is set then it will compress the data using the given method. The only option is zlib, more will be added later.
// If limit is 0 for either then there is no limit (until you run out of RAM that is).

// #embedBytes and #embedString only embed in the binary on release builds. This is done to speed up
// compile times during development. If not a release build it will be loaded at runtime.

// The following don't expand to anything, they are either defined or not.
#OS_MAC
#OS_WINDOWS
#OS_LINUX
#OS_FREE_BSD
#OS_OPEN_BSD
#OS_NONE

const RAND = #embedBytes("/dev/urandom") // Will crash the compiler, possibly your computer.
const ARR = #embedBytes("/dev/urandom", 128) // Type is [N]u8 where N is the number of elements determined at compile time.

let str: string = #embedString("hello.txt");
println(str) // hello.txt contents

#error(msg: string) // Causes the compiler to error with the given message.
#warn(msg: string) // Causes the compiler to emit a warning with the given message.
#info(msg: string) // Prints the message to stdout.

// [SIGNALS AND SLOTS] ----------------------------------------------------------------------------

// Instead of callbacks signals and slots can be used in Nifty. When a signal is emitted the
// corresponding slot or slots are called. This system is type safe so the signature of the signal
// and the slot must match. When a signal is emitted the emitter neither knows nor cares which slots
// receive the signal. If a signal is emitted all the corresponding slot will reveive it.
// Signals and slots can either be standalone functions or methods implemented on a struct. The
// two different types can be mixed. For instance a function can emit a signal that is recieved by
// a slot method. Signals do not have implementations and thus do not use the fn or md keywords.
// Slots on the other hand do have implementations so the fn or md keyword is required. This means
// that slots can be called like any normal function or method. One signal can be connected to many
// slots and vice versa. Signals can even be connected to other signals. When this is the case when
// the signal is emitted the signal connected to it is also immediatly emitted. If multiple signals
// or slots are connected togther they are executed in the order they were connected.
// Signals and slots can be slower than just using callbacks because there are runtime checks that
// happen in the background to make sure the calls to any objects are safe. However in almost all
// cases the convenience and flexability is woth the overhead.

// Signals must never return a type, they must be void.
signal valueChanged(newVal: int)

// Slots can return a type as they are otherwise normal functions. However in many cases the return
// value will be discarded. Because of this the #[keep] attribute can't be used with slots.
slot fn setValue(newVal: int) {
    someVal = newVal
}

#connect_fn(valueChanged, setValue)

// Optionally the types can be specified.
#connect_fn(valueChanged(int), setValue(int))

// ...

emit valueChanged(changedVal)

#connect_fn(emitterFn, receiverFn)
#connect_md(^emitter, Emitter::method, ^receiver, Receiver::method)
#connect_fn_md(emitterFn, ^receiver, Receiver::method)
#connect_md_fn(^emitter, Emitter::method, receiverFn)

emit emitterFn()


// [MISC] -----------------------------------------------------------------------------------------

b := false
assert(type_from(b) == bool) // true
assert(type_of(b) == "bool") // true

let c: type_from(b) // c is type bool
assert(type_from(c) == bool) // true
assert(type_of(c) == "bool") // true

typeid_of()

num := 42.f
assert(size_of(num) == 4) // true

type Point struct {
    x: f32
    y: f32
}

assert(align_of(Point) == 4) // true

restrict // See https://en.wikipedia.org/wiki/Restrict

fn updatePointers(restrict ptrA: ^int, restrict ptrB: ^int, restrict value: ^int) {
    ptrA^ += value^
    ptrB^ += value^
}

fn updatePointers(restrict ptrA, ptrB, value: ^int) { /- ... -/ }
// It is important to note that if the function is formed like this 'restrict' only applies to ptrA.
fn updatePointers(restrict ptrA, restrict ptrB, restrict value: ^int) { /- ... -/ } // Better

// [BUILDING] [CONFIG] ----------------------------------------------------------------------------

// The build file is done with TOML. The default build file name is 'nifty.toml'.
// Each build file can have multiple targets.

// A common usecase for having multiple targets is having a debug build and a production build.

project = string

[<TargetName:string>]
outputName = string 
// Name of the output.
entryPoint = string 
// The file containing 'main()'.
noEntryPoint = bool 
// Set to true to remove the requirement for a 'main()' function. Defaults to false.
noDepreciated = bool 
// Error if a function marked depreciated is used. Disabled by default.
noGoto = bool 
// Error if goto is used. Enabled by default.
debug = bool 
// Compile to debug mode. Disabled by default.
defines = [string] 
// defines = ["name=value", "name2=value2"]
errorOnWarn = bool 
// Treat warnings as errors. Disabled by default.
noWarn = bool 
// Disable warnings. Disabled by default.
optimization = string 
// Sets the optimization level. Options are none, fast, size, debug. 
// Defaults to "none". This is set to 'debug' if debug mode is enabled.
default = bool 
// Defaults to true in the first target, otherwise false. Can only be true for one target at a time.
noBoundsChecks = bool 
// Disables bounds checking for the entire program. Defaults to false.
children = [string]
// List of child targets that will be run when this target is complete.
disallowNull = bool
// If eanbled pointers will not be allowed to be null. Defaults to false.
macroRecursionDepth = int
// The number of nexted macros that are allowed to exist. Defaults to 2.
executeBefore = [[string], [string]]
// Array of paths to scripts or commands to be executed before compiling begins.
executeAfter = [[string], [string]]
// Array of paths to scripts or commands to be executed after compiling finishes.
// executeBefore, and executeAfter can be set to only execute on a certain platform
executeBefore = [["windows"], ["some/path/script.bat"]] // Will only run on windows.
executeBefore = [["unix"], ["some/path/script.sh"]] // Will only run on unix-like systems (mac, linux, bsd).
executeBefore = [["mac"], ["macSpecificCmd -withArg"]] // Will only run on mac.
// The above 3 examples can all be in the same project simultaneously and will be executed in order.
// To run on all use 'all'.
executeAfter = [["all"], ["bla"]]
// Valid options are mac, windows, linux, unix, bsd, freeBsd, openBsd, all.
// Where unix is a superset of linux, mac, bsd.
// Where bsd is a superset of freeBsd, openBsd.
deprecatedAfterWarnWithin = int
// If deprecatedAfter is used on a function this will start emitting a warning x number of days before
// the date given to deprecatedAfter that the function will be depreciated soon.

/-

nifty new // Interactive dialog to create a new nifty project

nifty build // Builds using the default build file in the current directory.
nifty build [fileName.extension] // Builds using the specified build file or source file.
nifty build [targetName] // Builds using the specified target with the default build file.
nifty build [buildFile]:[targetName] // Builds using the specified target with the specified build file.

nifty run // Takes the same arguments as 'nifty build' but builds and then runs the project.

nifty run prod // Builds and runs using 'nifty.toml' with target 'prod'.
nifty run server:debug // Builds and runs using 'server.toml' with target 'debug'

When not specifying a target the first target is used by default. Targets can optionally be marked
as the default. Only one target may be marked as default at a time.

nifty create [options] // Creates a new nifty project. Like nifty new but requires no user interaction.
nifty create name=tst

If no command is given then 'run' is used by default.

nifty [fileName.extension] // Same as nifty run [fileName.extension]
nifty [targetName] // Same as nifty run [targetName]
nifty [buildFile]:[targetName] // Same as nifty run [buildFile]:[targetName]
nifty // Will run the default target in the default build file.

If a target has the same name as a command then the command must be used as well.
For instance if you had a build target you would have to use
nifty run build
or
nifty build build

-/

// [KEYWORDS] -------------------------------------------------------------------------------------

if
else
elif
while
until
do
for
step
return
when
break
continue
impl
constimpl
endimpl
in
asm
defer
restrict
goto
cast
recast
auto_cast
type_of
type_from
size_of
name_of
align_of
new
delete
null
unused
undefined
true
false
this
package
use
using
as
behavior
does
struct
enum
bool
b8
b16
b32
b64
char
string
int
uint
float
double
s8
s16
s32
s64
s128
u8
u16
u32
u64
u128
f16
f32
f64
void
error
let
val
const
fn
md
type
emit
signal
slot

// Built in functions
assert
panic

// [TODO / MAYBE] ---------------------------------------------------------------------------------

/-

If there is a question mark after that means I'm not sure if I want to add that
to the language. Otherwise it is something I want in the language I just haven't
written it into the spec yet.

coroutines (?)
compiletime code execution (JIT) (?)
macros
user attributes
custom memory allocators
matrix data type (?)
complex number data type (?)
foreign keyword (use foreign)
static
operator overloading (?)
rawptr (void* in c) (?)
error handling (panic)

-/
